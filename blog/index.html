<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blog · 柳小白</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Be Water, My Friend!"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blog · 柳小白"/><meta property="og:type" content="website"/><meta property="og:url" content="https://github.com/stupidWall/liuxiaobai/liuxiaobai/"/><meta property="og:description" content="Be Water, My Friend!"/><meta property="og:image" content="https://github.com/stupidWall/liuxiaobai/liuxiaobai/img/1.jpeg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://github.com/stupidWall/liuxiaobai/liuxiaobai/img/1.jpeg"/><link rel="shortcut icon" href="/liuxiaobai/"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night.min.css"/><link rel="alternate" type="application/atom+xml" href="https://github.com/stupidWall/liuxiaobai/liuxiaobai/blog/atom.xml" title="柳小白 Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://github.com/stupidWall/liuxiaobai/liuxiaobai/blog/feed.xml" title="柳小白 Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/liuxiaobai/js/scrollSpy.js"></script><link rel="stylesheet" href="/liuxiaobai/css/main.css"/><script src="/liuxiaobai/js/codetabs.js"></script></head><body class="blog"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/liuxiaobai/"><h2 class="headerTitle">柳小白</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/liuxiaobai/blog/" target="_self">Blog</a></li><li class=""><a href="https://github.com/stupidWall/liuxiaobai" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>All Blog Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">All Blog Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/14/Object.assign">模拟实现Object.assign</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/14/TypeScript">TypeScript</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/12/utils">收集开源项目好用工具函数</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/12/TaroUi">taro-ui</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/11/events">读Taro消息机制源码笔记</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/10/面试题">火爆了的前端面试题</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/泛型">泛型（TypeScript学习笔记）</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/格式化日期">格式化日期</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/枚举">枚举（TypeScript学习笔记）</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/react生命周期">React生命周期</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/parseStyle">内联样式转对象</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/05/驼峰">中横线转驼峰变量</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/08/14/Object.assign">模拟实现Object.assign</a></h1><p class="post-meta">August 14, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="objectassign"></a><a href="#objectassign" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object.assign</h2>
<h3><a class="anchor" aria-hidden="true" id="用法"></a><a href="#用法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>用法</h3>
<p>用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> target = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> source = { <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">5</span> };

<span class="hljs-keyword">const</span> returnedTarget = <span class="hljs-built_in">Object</span>.assign(target, source);

<span class="hljs-built_in">console</span>.log(target);
<span class="hljs-comment">// expected output: Object { a: 1, b: 4, c: 5 }</span>

<span class="hljs-built_in">console</span>.log(returnedTarget);
<span class="hljs-comment">// expected output: Object { a: 1, b: 4, c: 5 }</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="实现"></a><a href="#实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.assign !== <span class="hljs-string">'function'</span>) {
  <span class="hljs-built_in">Object</span>.assign = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>{
    <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Connot convert undefined or null to object'</span>)
    }
    <span class="hljs-keyword">const</span> to = <span class="hljs-built_in">Object</span>(target)
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>; index &lt; <span class="hljs-built_in">arguments</span>.length; index++) {
      <span class="hljs-keyword">const</span> nextSource = <span class="hljs-built_in">arguments</span>[index]
      <span class="hljs-keyword">if</span> (nextSource != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> nextKey <span class="hljs-keyword">in</span> nextSource) {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey]
          }
        }
      }
    }
    <span class="hljs-keyword">return</span> to
  }
}
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/07/14/TypeScript">TypeScript</a></h1><p class="post-meta">July 14, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h1><a class="anchor" aria-hidden="true" id="安装-typescript"></a><a href="#安装-typescript" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>安装 TypeScript</h1>
<p>命令行运行如下命令，全局安装 TypeScript：</p>
<pre><code class="hljs css language-bash">npm install -g typescript
</code></pre>
<p>安装完成后，在控制台运行如下命令，检查安装是否成功：</p>
<pre><code class="hljs css language-bash">tsc -V 
</code></pre>
<h1><a class="anchor" aria-hidden="true" id="编写第一个-typescript-程序"></a><a href="#编写第一个-typescript-程序" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>编写第一个 TypeScript 程序</h1>
<p>在编辑器，将下面的代码输入到 greeter.ts 文件里：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, '</span> + person
}

<span class="hljs-keyword">let</span> user = <span class="hljs-string">'Yee'</span>

<span class="hljs-built_in">console</span>.log(greeter(user))
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="编译代码"></a><a href="#编译代码" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>编译代码</h2>
<p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p>
<p>在命令行上，运行 TypeScript 编译器：</p>
<pre><code class="hljs css language-bash">tsc greeter.ts
</code></pre>
<p>输出结果为一个 <code>greeter.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>
<p>在命令行上，通过 Node.js 运行这段代码：</p>
<pre><code class="hljs css language-bash">node greeter.js
</code></pre>
<p>控制台输出：</p>
<pre><code class="hljs"><span class="hljs-built_in">Hello,</span> Yee
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="类型注解"></a><a href="#类型注解" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类型注解</h2>
<p>接下来让我们看看 TypeScript 工具带来的高级功能。 给  <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, '</span> + person
}

<span class="hljs-keyword">let</span> user = <span class="hljs-string">'Yee'</span>

<span class="hljs-built_in">console</span>.log(greeter(user))
</code></pre>
<p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person: <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, '</span> + person
}

<span class="hljs-keyword">let</span> user = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]

<span class="hljs-built_in">console</span>.log(greeter(user))
</code></pre>
<p>重新编译，你会看到产生了一个错误：</p>
<pre><code class="hljs"><span class="hljs-literal">error</span> TS2345: Argument <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-symbol">'number</span>[]' <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> assignable <span class="hljs-keyword">to</span> <span class="hljs-keyword">parameter</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-symbol">'string</span>'.
</code></pre>
<p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>
<p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p>
<h2><a class="anchor" aria-hidden="true" id="接口"></a><a href="#接口" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>接口</h2>
<p>让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 <code>firstName</code> 和 <code>lastName</code> 字段的对象。 在 <code>TypeScript</code> 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 <code>implements</code> 语句。</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">interface</span> Person {
  firstName: <span class="hljs-built_in">string</span>
  lastName: <span class="hljs-built_in">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person: Person</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, '</span> + person.firstName + <span class="hljs-string">' '</span> + person.lastName
}

<span class="hljs-keyword">let</span> user = {
  firstName: <span class="hljs-string">'Yee'</span>,
  lastName: <span class="hljs-string">'Huang'</span>
}

<span class="hljs-built_in">console</span>.log(greeter(user))
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="类"></a><a href="#类" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类</h2>
<p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p>
<p>让我们创建一个 <code>Student</code> 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。</p>
<p>还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">class</span> User {
  fullName: <span class="hljs-built_in">string</span>
  firstName: <span class="hljs-built_in">string</span>
  lastName: <span class="hljs-built_in">string</span>

  <span class="hljs-keyword">constructor</span> (<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">this</span>.firstName = firstName
    <span class="hljs-keyword">this</span>.lastName = lastName
    <span class="hljs-keyword">this</span>.fullName = firstName + <span class="hljs-string">' '</span> + lastName
  }
}

<span class="hljs-keyword">interface</span> Person {
  firstName: <span class="hljs-built_in">string</span>
  lastName: <span class="hljs-built_in">string</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person: Person</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, '</span> + person.firstName + <span class="hljs-string">' '</span> + person.lastName
}

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">'Yee'</span>, <span class="hljs-string">'Huang'</span>)

<span class="hljs-built_in">console</span>.log(greeter(user))
</code></pre>
<p>重新运行 <code>tsc greeter.ts</code>，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 <code>JavaScript</code> 函数的实现。</p>
<h1><a class="anchor" aria-hidden="true" id="基础类型"></a><a href="#基础类型" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基础类型</h1>
<p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>
<h2><a class="anchor" aria-hidden="true" id="布尔值"></a><a href="#布尔值" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>布尔值</h2>
<p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="数字"></a><a href="#数字" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数字</h2>
<p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> decLiteral: <span class="hljs-built_in">number</span> = <span class="hljs-number">20</span>
<span class="hljs-keyword">let</span> hexLiteral: <span class="hljs-built_in">number</span> = <span class="hljs-number">0x14</span>
<span class="hljs-keyword">let</span> binaryLiteral: <span class="hljs-built_in">number</span> = <span class="hljs-number">0b10100</span>
<span class="hljs-keyword">let</span> octalLiteral: <span class="hljs-built_in">number</span> = <span class="hljs-number">0o24</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="字符串"></a><a href="#字符串" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>字符串</h2>
<p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>'</code>）表示字符串。</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'bob'</span>
name = <span class="hljs-string">'smith'</span>
</code></pre>
<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <code>`</code>），并且以 <code>${ expr }</code> 这种形式嵌入表达式</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Yee`</span>
<span class="hljs-keyword">let</span> age: <span class="hljs-built_in">number</span> = <span class="hljs-number">37</span>
<span class="hljs-keyword">let</span> sentence: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">${ name }</span>.

I'll be <span class="hljs-subst">${ age + 1 }</span> years old next month.`</span>
</code></pre>
<p>这与下面定义 <code>sentence</code> 的方式效果相同：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> sentence: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Hello, my name is '</span> + name + <span class="hljs-string">'.\n\n'</span> +
    <span class="hljs-string">'I\'ll be '</span> + (age + <span class="hljs-number">1</span>) + <span class="hljs-string">' years old next month.'</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="数组"></a><a href="#数组" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数组</h2>
<p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</code></pre>
<p>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="元祖-tuple"></a><a href="#元祖-tuple" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>元祖 Tuple</h2>
<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> x: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]
x = [<span class="hljs-string">'hello'</span>, <span class="hljs-number">10</span>] <span class="hljs-comment">// OK</span>
x = [<span class="hljs-number">10</span>, <span class="hljs-string">'hello'</span>] <span class="hljs-comment">// Error</span>
</code></pre>
<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-built_in">console</span>.log(x[<span class="hljs-number">0</span>].substr(<span class="hljs-number">1</span>)) <span class="hljs-comment">// OK</span>
<span class="hljs-built_in">console</span>.log(x[<span class="hljs-number">1</span>].substr(<span class="hljs-number">1</span>)) <span class="hljs-comment">// Error, 'number' 不存在 'substr' 方法</span>
</code></pre>
<p>当访问一个越界的元素，会使用联合类型替代：</p>
<pre><code class="hljs css language-typescript">x[<span class="hljs-number">3</span>] = <span class="hljs-string">'world'</span> <span class="hljs-comment">// OK, 字符串可以赋值给(string | number)类型</span>

<span class="hljs-built_in">console</span>.log(x[<span class="hljs-number">5</span>].toString()) <span class="hljs-comment">// OK, 'string' 和 'number' 都有 toString</span>

x[<span class="hljs-number">6</span>] = <span class="hljs-literal">true</span> <span class="hljs-comment">// Error, 布尔不是(string | number)类型</span>
</code></pre>
<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>
<h2><a class="anchor" aria-hidden="true" id="枚举"></a><a href="#枚举" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>枚举</h2>
<p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">enum</span> Color {Red, Green, Blue}
<span class="hljs-keyword">let</span> c: Color = Color.Green
</code></pre>
<p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">enum</span> Color {Red = <span class="hljs-number">1</span>, Green, Blue}
<span class="hljs-keyword">let</span> c: Color = Color.Green
</code></pre>
<p>或者，全部都采用手动赋值：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">enum</span> Color {Red = <span class="hljs-number">1</span>, Green = <span class="hljs-number">2</span>, Blue = <span class="hljs-number">4</span>}
<span class="hljs-keyword">let</span> c: Color = Color.Green
</code></pre>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">enum</span> Color {Red = <span class="hljs-number">1</span>, Green, Blue}
<span class="hljs-keyword">let</span> colorName: <span class="hljs-built_in">string</span> = Color[<span class="hljs-number">2</span>]

<span class="hljs-built_in">console</span>.log(colorName)  <span class="hljs-comment">// 显示'Green'因为上面代码里它的值是2</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="any"></a><a href="#any" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>any</h2>
<p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> notSure: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span>
notSure = <span class="hljs-string">'maybe a string instead'</span>
notSure = <span class="hljs-literal">false</span> <span class="hljs-comment">// 也可以是个 boolean</span>
</code></pre>
<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">'free'</span>]

list[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="void"></a><a href="#void" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>void</h2>
<p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'This is my warning message'</span>)
}

</code></pre>
<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> unusable: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="null-和-undefined"></a><a href="#null-和-undefined" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>null 和 undefined</h2>
<p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 和 <code>void</code> 相似，它们的本身的类型用处不是很大：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>
<span class="hljs-keyword">let</span> n: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>
</code></pre>
<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>
<p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。 再次说明，稍后我们会介绍联合类型。</p>
<h2><a class="anchor" aria-hidden="true" id="never"></a><a href="#never" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>never</h2>
<p><code>never</code> 类型表示的是那些永不存在的值的类型。 例如， <code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 <code>never</code> 的子类型或可以赋值给<code>never</code> 类型（除了 <code>never</code> 本身之外）。 即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>
<p>下面是一些返回 <code>never</code> 类型的函数：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">error</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">never</span> </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message)
}

<span class="hljs-comment">// 推断的返回值类型为never</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fail</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> error(<span class="hljs-string">"Something failed"</span>)
}

<span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">infiniteLoop</span>(<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>{
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="object"></a><a href="#object" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>object</h2>
<p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code> 之外的类型。</p>
<p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。例如：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">o: object | <span class="hljs-literal">null</span></span>): <span class="hljs-title">void</span>

<span class="hljs-title">create</span>(<span class="hljs-params">{ prop: 0 }</span>) // <span class="hljs-title">OK</span>
<span class="hljs-title">create</span>(<span class="hljs-params"><span class="hljs-literal">null</span></span>) // <span class="hljs-title">OK</span>

<span class="hljs-title">create</span>(<span class="hljs-params">42</span>) // <span class="hljs-title">Error</span>
<span class="hljs-title">create</span>(<span class="hljs-params">'<span class="hljs-built_in">string</span>'</span>) // <span class="hljs-title">Error</span>
<span class="hljs-title">create</span>(<span class="hljs-params"><span class="hljs-literal">false</span></span>) // <span class="hljs-title">Error</span>
<span class="hljs-title">create</span>(<span class="hljs-params"><span class="hljs-literal">undefined</span></span>) // <span class="hljs-title">Error</span>
</span></code></pre>
<h2><a class="anchor" aria-hidden="true" id="类型断言"></a><a href="#类型断言" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类型断言</h2>
<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> someValue: <span class="hljs-built_in">any</span> = <span class="hljs-string">'this is a string'</span>

<span class="hljs-keyword">let</span> strLength: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).length
</code></pre>
<p>另一个为 <code>as</code> 语法：</p>
<pre><code class="hljs css language-typescript"><span class="hljs-keyword">let</span> someValue: <span class="hljs-built_in">any</span> = <span class="hljs-string">'this is a string'</span>

<span class="hljs-keyword">let</span> strLength: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).length
</code></pre>
<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 <code>as</code> 语法断言是被允许的。</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/07/12/utils">收集开源项目好用工具函数</a></h1><p class="post-meta">July 12, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="深度克隆"></a><a href="#深度克隆" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>深度克隆</h3>
<p><a href="https://github.com/NervJS/taro/blob/master/packages/taro/src/util.js">源码地址</a></p>
<h5><a class="anchor" aria-hidden="true" id="代码"></a><a href="#代码" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码</h5>
<p>结合<code>while</code>循环和递归实现</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objClone</span> (<span class="hljs-params">jsonObj</span>) </span>{
  <span class="hljs-keyword">var</span> buf
  <span class="hljs-keyword">if</span> (jsonObj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) {
    buf = []
    <span class="hljs-keyword">var</span> i = jsonObj.length
    <span class="hljs-keyword">while</span> (i--) {
      buf[i] = objClone(jsonObj[i])
    }
    <span class="hljs-keyword">return</span> buf
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jsonObj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>) {
    buf = {}
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> jsonObj) {
      buf[k] = objClone(jsonObj[k])
    }
    <span class="hljs-keyword">return</span> buf
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> jsonObj
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="获取一个对象的原型"></a><a href="#获取一个对象的原型" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>获取一个对象的原型</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPrototype</span> (<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-comment">/* eslint-disable */</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.getPrototypeOf) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getPrototypeOf(obj)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj.__proto__) {
    <span class="hljs-keyword">return</span> obj.__proto__
  }
  <span class="hljs-comment">/* eslint-enable */</span>
  <span class="hljs-keyword">return</span> obj.constructor.prototype
</code></pre>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf介绍</a></p>
<h3><a class="anchor" aria-hidden="true" id="获取一个对象的原型链"></a><a href="#获取一个对象的原型链" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>获取一个对象的原型链</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPrototypeChain</span> (<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">const</span> protoChain = []
  <span class="hljs-keyword">while</span> (obj = getPrototype(obj)) {
    protoChain.push(obj)
  }
  <span class="hljs-keyword">return</span> protoChain
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="判断一个对象是否空对象"></a><a href="#判断一个对象是否空对象" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>判断一个对象是否空对象</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmptyObject</span> (<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">if</span> (!obj) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> n <span class="hljs-keyword">in</span> obj) {
    <span class="hljs-keyword">if</span> (obj.hasOwnProperty(n) &amp;&amp; obj[n]) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/07/12/TaroUi">taro-ui</a></h1><p class="post-meta">July 12, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="样式"></a><a href="#样式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>样式</h3>
<ul>
<li>入口</li>
</ul>
<pre><code class="hljs css language-css">@<span class="hljs-keyword">import</span> <span class="hljs-string">"./style/index.scss"</span>;
</code></pre>
<ul>
<li>小程序<code>page</code>节点默认<code>flex</code>样式</li>
</ul>
<pre><code class="hljs css language-css"><span class="hljs-selector-class">.page</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">flex-direction</span>: column;
  <span class="hljs-attribute">box-sizing</span>: border-box;
  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f8f8f8</span>;
}
</code></pre>
<ul>
<li>全局<code>view</code>标签元素设置为怪异盒模型</li>
</ul>
<pre><code class="hljs css language-css"><span class="hljs-selector-tag">view</span> {
  <span class="hljs-attribute">box-sizing</span>: border-box;
}
</code></pre>
<ul>
<li><code>style</code>目录下文件结构
<ul>
<li><code>index.scss</code> 入口文件</li>
<li><code>variables</code>变量管理
<ul>
<li>它这里变量管理的方案是，<code>$color-</code>第一个词表明是颜色，<code>$color-bg</code> 、 <code>$color-border</code>第二个词表明是用在什么上的颜色， <code>$color-bg-base</code>第三个次表明这个颜色的定位，可根据自己的需求自定义</li>
<li>这里主要定义的变量有以下方面的
<pre><code class="hljs">  <span class="hljs-variable">$color</span>-xxx 颜色
  <span class="hljs-variable">$border</span>-radius-xxx 边框倒圆
  <span class="hljs-variable">$opacity</span>-xxx 透明度
  <span class="hljs-variable">$font</span>-size 字体大小
  组件变量
  <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>
</code></pre></li>
</ul></li>
<li><code>themes</code> 主题样式</li>
<li><code>mixins</code> 混入(共用方法)
<ul>
<li>里面有一个<code>index.scss</code>入口， <code>libs</code>目录分别管理不一样的<code>mixin</code></li>
<li>元素居中
<pre><code class="hljs css language-css">/**
* 元素居中定位
*/
@mixin absolute-center($pos: absolute) {
  position: $pos;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
</code></pre></li>
<li>超出省略
<pre><code class="hljs css language-css">@mixin line($num: 1) {
  overflow: hidden;
  text-overflow: ellipsis;

  @if ($num == 1) {
    white-space: nowrap;
  } @else {
    display: -webkit-box;
    -webkit-line-clamp: $num;

    /* autoprefixer: off */
    -webkit-box-orient: vertical;
  }
}
</code></pre></li>
<li>遮罩
<pre><code class="hljs css language-css">@mixin overlay {
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  position: absolute;
  background-color: rgba($color: #000, $alpha: 0.3);
}
</code></pre></li>
</ul></li>
<li><code>components</code> 组件样式统一在这个目录下
<ul>
<li>里面也有一个<code>index.scss</code>入口文件</li>
</ul></li>
</ul></li>
</ul>
<p><img src="https://raw.githubusercontent.com/stupidWall/liuxiaobai/master/img/blog/20190802141306.jpg" alt=""></p>
<ul>
<li><a href="https://www.sass.hk/docs/">scss文档</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="按钮组件"></a><a href="#按钮组件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>按钮组件</h3>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/07/11/events">读Taro消息机制源码笔记</a></h1><p class="post-meta">July 11, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="使用"></a><a href="#使用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> Taro, { Events } <span class="hljs-keyword">from</span> <span class="hljs-string">'@tarojs/taro'</span>

<span class="hljs-keyword">const</span> events = <span class="hljs-keyword">new</span> Events()

<span class="hljs-comment">// 监听一个事件，接受参数</span>
events.on(<span class="hljs-string">'eventName'</span>, (arg) =&gt; {
  <span class="hljs-comment">// doSth</span>
})

<span class="hljs-comment">// 监听同个事件，同时绑定多个 handler</span>
events.on(<span class="hljs-string">'eventName'</span>, handler1)
events.on(<span class="hljs-string">'eventName'</span>, handler2)
events.on(<span class="hljs-string">'eventName'</span>, handler3)

<span class="hljs-comment">// 触发一个事件，传参</span>
events.trigger(<span class="hljs-string">'eventName'</span>, arg)

<span class="hljs-comment">// 触发事件，传入多个参数</span>
events.trigger(<span class="hljs-string">'eventName'</span>, arg1, arg2, ...)

<span class="hljs-comment">// 取消监听一个事件</span>
events.off(<span class="hljs-string">'eventName'</span>)

<span class="hljs-comment">// 取消监听一个事件某个 handler</span>
events.off(<span class="hljs-string">'eventName'</span>, handler1)

<span class="hljs-comment">// 取消监听所有事件</span>
events.off()
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="初步分析功能要点"></a><a href="#初步分析功能要点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>初步分析功能要点</h3>
<ul>
<li>注册监听事件： 自定义事件名，指定事件触发执行函数，可以指定上下文</li>
<li>触发事件： 指定触发的事件名，可传入相关参数</li>
<li>取消事件监听： 可取消指定事件，可取消所有事件</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="初步解析"></a><a href="#初步解析" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>初步解析</h3>
<p>大致看下源码，有一个整体观，切记一上来就一股脑钻进某个细节里。</p>
<ul>
<li><p>从源码里，可以大概知道，作者是通过<code>class</code>面向对象的方式实现，内部管理一个<code>callbacks</code>对象，注册一个事件，往对象里添加一个事件属性对象，事件属性对象下有几个属性，一个是事件回调函数<code>callback</code>，一个是执行上下文<code>context</code>，还有一个<code>next</code>， 作用是多个<code>callback</code>对象嵌套。</p></li>
<li><p>触发事件时，通过事件名，找到对应的对象，完成回调函数的执行。</p></li>
<li><p>取消事件时，根据取消事件的名，找到对应的对象，删掉。 如果没有传事件名， <code>callbacks</code>全部删除。</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="二次分析"></a><a href="#二次分析" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>二次分析</h3>
<p>上面的分析是一个事件监听器最基本的功能，现在分析一下其他的情况和功能</p>
<ul>
<li><p>问题1： 注册了一个事件，绑定一个回调函数，如果针对这个事件绑定多个回调函数，怎么办，而且在这种情况下触发顺序是要根据绑定先后顺序依次执行，怎么能保证这个顺序问题。</p>
<pre><code class="hljs"><span class="hljs-meta"># 解决思路</span>
<span class="hljs-comment">// 第一次注册onClick事件， 回调函数handle1, callbacks对象是这样的：</span>
{
<span class="hljs-symbol">    onClick:</span> {
<span class="hljs-symbol">        next:</span> {
<span class="hljs-symbol">            callback:</span> handle1,
<span class="hljs-symbol">            context:</span> undefined,
<span class="hljs-symbol">            next:</span> {}
        }
    }
}

<span class="hljs-comment">// 第二次：</span>
{
<span class="hljs-symbol">    onClick:</span> {
<span class="hljs-symbol">        next:</span> {
<span class="hljs-symbol">            callback:</span> handle1,
<span class="hljs-symbol">            context:</span> undefined,
<span class="hljs-symbol">            next:</span> {
<span class="hljs-symbol">                callback:</span> handle2,
<span class="hljs-symbol">                context:</span> undefined,
<span class="hljs-symbol">                next:</span> {}
            }
        }
    }
}

<span class="hljs-comment">// 以此类推...</span>

当在触发的时候， 根据这个对象，依次从外往里层层执行

思路和方向是这样的，具体怎么实现，后面看源码就一目了然
</code></pre></li>
<li><p>问题2: 只监听一次的需求怎么实现，意思是，注册一个事件，然后一旦触发，就取消掉这个事件的监听，再没机会触发。</p>
<pre><code class="hljs"><span class="hljs-comment"># 解决思路</span>
注册一个事件，绑定一个对应的函数。

同样的思路，你注册一个事件，完成一个回调任务A,  在内部我保证触发的时候完成你的回调任务A的同时，我多做一件事（取消）， 即重新包装一个新的回调给到注册函数

const wrapper = <span class="hljs-function"><span class="hljs-params">(...args)</span> =&gt;</span> {
  callback.apply(<span class="hljs-keyword">this</span>, args)
  <span class="hljs-keyword">this</span>.<span class="hljs-literal">off</span>(events, wrapper, context)
}
<span class="hljs-keyword">this</span>.<span class="hljs-literal">on</span>(events, wrapper, context)
</code></pre></li>
<li><p>问题3: 取消事件的时候，如果我要实现只是取消一个事件里某个回调<code>handle</code>，意思是，一个事件可能绑定<code>handle1</code>、<code>handle2</code>， 现在做到触发时不要执行<code>handle2</code>， 怎么思路？</p>
<pre><code class="hljs"><span class="hljs-meta"># 解决思路</span>
如果是这种情况，可以把handle2忽略掉，把关注点放在剩下的handle1，即把这些剩下的，没取消的handle都重新的注册一遍

<span class="hljs-comment">// 这个判断作用，过滤被取消的handle， 其他的重新注册一遍</span>
<span class="hljs-keyword">if</span> ((callback &amp;&amp; cb !== callback) || (context &amp;&amp; ctx !== context)) {
    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">on</span>(<span class="hljs-keyword">event</span>, cb, ctx)
}
</code></pre></li>
</ul>
<p>理解完上面的思路，对下面的源码，看起来就很顺畅。 思路一样，实现方式可以有多种，只是作者的写法也很值得学习。</p>
<h3><a class="anchor" aria-hidden="true" id="源码代码"></a><a href="#源码代码" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码代码</h3>
<p><a href="https://github.com/NervJS/taro/blob/master/packages/taro/src/events.js">Taro-Events源码地址</a></p>
<pre><code class="hljs css language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Events</span> </span>{
  <span class="hljs-keyword">constructor</span> (opts) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> opts !== <span class="hljs-string">'undefined'</span> &amp;&amp; opts.callbacks) {
      <span class="hljs-keyword">this</span>.callbacks = opts.callbacks
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.callbacks = {}
    }
  }

  on (events, callback, context) {
    <span class="hljs-keyword">let</span> calls, event, node, tail, list
    <span class="hljs-keyword">if</span> (!callback) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }
    events = events.split(Events.eventSplitter)
    calls = <span class="hljs-keyword">this</span>.callbacks
    <span class="hljs-keyword">while</span> ((event = events.shift())) {
      list = calls[event]
      node = list ? list.tail : {}
      node.next = tail = {}
      node.context = context
      node.callback = callback
      calls[event] = {
        tail,
        <span class="hljs-attr">next</span>: list ? list.next : node
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }

  once (events, callback, context) {
    <span class="hljs-keyword">const</span> wrapper = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
      callback.apply(<span class="hljs-keyword">this</span>, args)
      <span class="hljs-keyword">this</span>.off(events, wrapper, context)
    }

    <span class="hljs-keyword">this</span>.on(events, wrapper, context)

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }

  off (events, callback, context) {
    <span class="hljs-keyword">let</span> event, calls, node, tail, cb, ctx
    <span class="hljs-keyword">if</span> (!(calls = <span class="hljs-keyword">this</span>.callbacks)) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }
    <span class="hljs-keyword">if</span> (!(events || callback || context)) {
      <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.callbacks
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }
    events = events ? events.split(Events.eventSplitter) : <span class="hljs-built_in">Object</span>.keys(calls)
    <span class="hljs-keyword">while</span> ((event = events.shift())) {
      node = calls[event]
      <span class="hljs-keyword">delete</span> calls[event]
      <span class="hljs-keyword">if</span> (!node || !(callback || context)) {
        <span class="hljs-keyword">continue</span>
      }
      tail = node.tail
      <span class="hljs-keyword">while</span> ((node = node.next) !== tail) {
        cb = node.callback
        ctx = node.context
        <span class="hljs-keyword">if</span> ((callback &amp;&amp; cb !== callback) || (context &amp;&amp; ctx !== context)) {
          <span class="hljs-keyword">this</span>.on(event, cb, ctx)
        }
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }

  trigger (events) {
    <span class="hljs-keyword">let</span> event, node, calls, tail, rest
    <span class="hljs-keyword">if</span> (!(calls = <span class="hljs-keyword">this</span>.callbacks)) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
    }
    events = events.split(Events.eventSplitter)
    rest = [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">while</span> ((event = events.shift())) {
      <span class="hljs-keyword">if</span> ((node = calls[event])) {
        tail = node.tail
        <span class="hljs-keyword">while</span> ((node = node.next) !== tail) {
          node.callback.apply(node.context || <span class="hljs-keyword">this</span>, rest)
        }
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }
}

Events.eventSplitter = <span class="hljs-regexp">/\s+/</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Events
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="其他"></a><a href="#其他" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>其他</h4>
<p><code>Events.eventSplitter = /\s+/</code>、 <code>events = events.split(Events.eventSplitter)</code> 这个的作用是, 如果事件名是<code>'onClick onTouch'</code>这样的情况， 是能够对2种自定义事件完成注册</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/07/10/面试题">火爆了的前端面试题</a></h1><p class="post-meta">July 10, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="100"></a><a href="#100" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>#<code>100</code></h3>
<p>请写出如下代码的打印结果</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>{
    Foo.a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)
    }
    <span class="hljs-keyword">this</span>.a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)
    }
}
Foo.prototype.a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)
}
Foo.a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)
}
Foo.a();
<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> Foo();
obj.a();
Foo.a();
</code></pre>
<pre><code class="hljs"><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="99"></a><a href="#99" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>#<code>99</code></h3>
<p>用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">let</span> num1 = num / <span class="hljs-number">10</span>;
    <span class="hljs-keyword">let</span> num2 = num % <span class="hljs-number">10</span>;
    <span class="hljs-keyword">if</span>(num1&lt;<span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> num;
    }<span class="hljs-keyword">else</span>{
        num1 = <span class="hljs-built_in">Math</span>.floor(num1)
        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${num2}</span><span class="hljs-subst">${fun(num1)}</span>`</span>
    }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="98"></a><a href="#98" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>#<code>98</code></h3>
<p>写出如下代码的打印结果</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeObjProperty</span>(<span class="hljs-params">o</span>) </span>{
  o.siteUrl = <span class="hljs-string">"http://www.baidu.com"</span>
  o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()
  o.siteUrl = <span class="hljs-string">"http://www.google.com"</span>
} 
<span class="hljs-keyword">let</span> webSite = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
changeObjProperty(webSite);
<span class="hljs-built_in">console</span>.log(webSite.siteUrl);

</code></pre>
<pre><code class="hljs css language-javascript">http:<span class="hljs-comment">//www.baidu.com</span>
</code></pre>
<p>考察对象引用类型。 <code>webSite</code>是一个指针，指向堆内存里的某一具体地址， <code>o.siteUrl = &quot;http://www.baidu.com&quot;</code>, 即这个具体地址里多了个属性。 <code>o = new Object()</code>,  现在<code>o</code>指针指向了另外一个堆地址，跟刚才那个完全不在一个位置。</p>
<h3><a class="anchor" aria-hidden="true" id="97"></a><a href="#97" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>#<code>97</code></h3>
<p>React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的?</p>
<pre><code class="hljs">略
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="95"></a><a href="#95" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>#<code>95</code></h3>
<p>模拟实现一个深拷贝，并考虑对象相互引用以及 Symbol 拷贝的情况</p>
<pre><code class="hljs">略
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/07/06/泛型">泛型（TypeScript学习笔记）</a></h1><p class="post-meta">July 6, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="泛型"></a><a href="#泛型" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>泛型</h3>
<p>解决函数传入参数类型与函数返回值类型一致的问题。</p>
<p>一个函数，我希望传入数字，返回数字；传入字符串，返回字符串， 即</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span> (<span class="hljs-params">a: number</span>): <span class="hljs-title">number</span> </span>{
  <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span> (<span class="hljs-params">b: string</span>): <span class="hljs-title">string</span> </span>{
  <span class="hljs-keyword">return</span> b + <span class="hljs-string">' :fn2'</span>
}
</code></pre>
<p>有没有支持不同类型的方式，any</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span> (<span class="hljs-params">c: any</span>): <span class="hljs-title">any</span> </span>{
  <span class="hljs-keyword">return</span> c
}
</code></pre>
<p>可是使用any，不能保证返回值类型和传入参数类型属于相同类型</p>
<p>使用泛型！</p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">a: T</span>): <span class="hljs-title">T</span></span>{
  <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>
}
</code></pre>
<p>可以看到，使用尖括号<T>即可使用泛型函数</p>
<blockquote>
<p>还有一种方式使用泛型函数：类型推断，什么也不用做，智能判断</p>
</blockquote>
<p>有个问题，下面的泛型函数，函数体中访问了参数的<code>length</code>属性，如果传入参数属字符串或数组，没问题，但如果是<code>number</code>类型呢，<code>length</code>属性肯定是<code>undefined</code></p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">a: T</span>): <span class="hljs-title">T</span></span>{
  <span class="hljs-built_in">console</span>.log(a.length)
  <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>
}
</code></pre>
<p>使用泛型变量， 声明泛型数组即可</p>
<pre><code class="hljs css language-javascript">function fn1&lt;T&gt;(a: T[]): T[]{
  console.log(a.length)
  return a + 1
}
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/07/06/格式化日期">格式化日期</a></h1><p class="post-meta">July 6, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="代码如下"></a><a href="#代码如下" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码如下</h3>
<p><a href="https://github.com/didi/cube-ui/blob/dev/src/common/lang/date.js">开源项目链接地址</a></p>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatType</span>(<span class="hljs-params">type, format, value, regExpAttributes</span>) </span>{
  <span class="hljs-keyword">const</span> regExpMap = {
    <span class="hljs-attr">year</span>: <span class="hljs-string">'(Y+)'</span>,
    <span class="hljs-attr">month</span>: <span class="hljs-string">'(M+)'</span>,
    <span class="hljs-attr">date</span>: <span class="hljs-string">'(D+)'</span>,
    <span class="hljs-attr">hour</span>: <span class="hljs-string">'(h+)'</span>,
    <span class="hljs-attr">minute</span>: <span class="hljs-string">'(m+)'</span>,
    <span class="hljs-attr">second</span>: <span class="hljs-string">'(s+)'</span>,
    <span class="hljs-attr">quarter</span>: <span class="hljs-string">'(q+)'</span>,
    <span class="hljs-attr">millisecond</span>: <span class="hljs-string">'(S)'</span>
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(regExpMap[type], regExpAttributes).test(format)) {
    <span class="hljs-keyword">const</span> replaceStr = type === <span class="hljs-string">'year'</span>
                       ? value.toString().substr(<span class="hljs-number">4</span> - <span class="hljs-built_in">RegExp</span>.$<span class="hljs-number">1.</span>length)
                       : (<span class="hljs-built_in">RegExp</span>.$<span class="hljs-number">1.</span>length === <span class="hljs-number">1</span>) ? value : pad(value)
    format = format.replace(<span class="hljs-built_in">RegExp</span>.$<span class="hljs-number">1</span>, replaceStr)
  }

  <span class="hljs-keyword">return</span> format
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pad</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-string">'00'</span> + value).substr((<span class="hljs-string">''</span> + value).length)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatDate</span>(<span class="hljs-params">date, format</span>) </span>{
  <span class="hljs-keyword">const</span> map = {
    <span class="hljs-attr">year</span>: {
      <span class="hljs-attr">value</span>: date.getFullYear(),
      <span class="hljs-attr">regExpAttributes</span>: <span class="hljs-string">'i'</span>
    },
    <span class="hljs-attr">month</span>: {
      <span class="hljs-attr">value</span>: date.getMonth() + <span class="hljs-number">1</span>
    },
    <span class="hljs-attr">date</span>: {
      <span class="hljs-attr">value</span>: date.getDate(),
      <span class="hljs-attr">regExpAttributes</span>: <span class="hljs-string">'i'</span>
    },
    <span class="hljs-attr">hour</span>: {
      <span class="hljs-attr">value</span>: date.getHours(),
      <span class="hljs-attr">regExpAttributes</span>: <span class="hljs-string">'i'</span>
    },
    <span class="hljs-attr">minute</span>: {
      <span class="hljs-attr">value</span>: date.getMinutes()
    },
    <span class="hljs-attr">second</span>: {
      <span class="hljs-attr">value</span>: date.getSeconds()
    },
    <span class="hljs-attr">quarter</span>: {
      <span class="hljs-attr">value</span>: <span class="hljs-built_in">Math</span>.floor((date.getMonth() + <span class="hljs-number">3</span>) / <span class="hljs-number">3</span>),
      <span class="hljs-attr">regExpAttributes</span>: <span class="hljs-string">'i'</span>
    },
    <span class="hljs-attr">millisecond</span>: {
      <span class="hljs-attr">value</span>: date.getMilliseconds()
    }
  }

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> map) {
    format = formatType(key, format, map[key].value, map[key].regExpAttributes)
  }

  <span class="hljs-keyword">return</span> format
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="测试"></a><a href="#测试" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>测试</h4>
<pre><code class="hljs"><span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'result:'</span>,
  formatDate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), <span class="hljs-string">'YYYY.MM.DD hh:mm'</span>)
)
</code></pre>
<p><img src="https://raw.githubusercontent.com/stupidWall/liuxiaobai/master/img/blog/2019/20190706101213.jpg" /></p>
<h4><a class="anchor" aria-hidden="true" id="演绎过程"></a><a href="#演绎过程" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>演绎过程</h4>
<p>根据传入日期对象参数，获得对应的月份<code>7</code>, 根据匹配规则<code>YYYY.MM.DD hh:mm</code>， 通过正则<code>(M+)</code>找出<code>MM</code>, 接着把<code>7</code>替换<code>MM</code>， 同时使用<code>pad</code>函数处理下<code>7</code> =&gt; <code>07</code>, <code>24</code> =&gt; <code>24</code>情况，以此类推。</p>
<h4><a class="anchor" aria-hidden="true" id="补零-pad"></a><a href="#补零-pad" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>补零<code>pad</code></h4>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pad</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-string">'00'</span> + value).substr((<span class="hljs-string">''</span> + value).length)
}
</code></pre>
<p>如果值<code>1</code>位数<code>7</code>, 前面加<code>00</code>, 即<code>007</code>, 剪掉<code>0</code>， 即<code>07</code></p>
<p>如果值<code>2</code>位数<code>24</code>, 前面加<code>00</code>, 即<code>0024</code>, 剪掉<code>00</code>， 即<code>24</code></p>
<p>共同点，剪掉的是值的长度。</p>
<p>数字 + 字符串，一定是字符串相加，不是数字的累加，这点要注意。</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/07/06/枚举">枚举（TypeScript学习笔记）</a></h1><p class="post-meta">July 6, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="枚举"></a><a href="#枚举" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>枚举</h3>
<p><a href="https://codepen.io/stupidWall/pen/pXOQdN?editors=0010">戳我试试</a></p>
<h4><a class="anchor" aria-hidden="true" id="数字枚举"></a><a href="#数字枚举" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数字枚举</h4>
<p>假设后台定义三个状态：</p>
<p><code>1</code> 待支付
<code>2</code> 待发货
<code>3</code> 已完成</p>
<p>前端使用的时候，如果整个项目中到处都是<code>1</code>、<code>2</code>、<code>3</code>, 有个问题就是不够语义，维护起来时间成本也较高， 想办法映射成变量：</p>
<pre><code class="hljs css language-javascript">enum Status {
  outPay = <span class="hljs-number">1</span>,
  outDelivery = <span class="hljs-number">2</span>,
  done = <span class="hljs-number">3</span>
}
</code></pre>
<p>当使用都时候，可以判断<code>Status.outPay === status</code>即可</p>
<p>针对数字枚举，还有一个反向映射， 即<code>Status[1]</code>值是<code>outPay</code></p>
<p>打印出<code>Status</code>可以看到</p>
<p><img src="https://raw.githubusercontent.com/stupidWall/liuxiaobai/master/img/blog/2019/20190706195943.jpg" width='600' /></p>
<h4><a class="anchor" aria-hidden="true" id="字符串枚举"></a><a href="#字符串枚举" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>字符串枚举</h4>
<pre><code class="hljs css language-javascript">enum newVal {
  a = <span class="hljs-string">'aa'</span>,
  b = <span class="hljs-string">'bb'</span>
}
</code></pre>
<blockquote>
<p>字符串枚举中没有反向映射</p>
</blockquote>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/07/06/react生命周期">React生命周期</a></h1><p class="post-meta">July 6, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="生命周期分两大类"></a><a href="#生命周期分两大类" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>生命周期分两大类</h3>
<ul>
<li>挂载&amp;卸载
<ul>
<li><p>挂载</p>
<ul>
<li>下面<code>2</code>个函数只会在组件初始化时运行一次</li>
<li><code>componentWillMount</code>： 在<code>render</code>函数之前执行， 可以使用<code>setState</code>， 但初始化只会运行一次，所以这里调用没意义，可以在<code>constructor</code>里初始化<code>state</code></li>
<li><code>componentDidMount</code> ： 在<code>render</code>函数之后执行， 可以<code>setState</code></li>
</ul></li>
<li><p>卸载</p>
<ul>
<li><code>componentWillUnmount</code>： 事件回收或清除定时器等工作</li>
</ul></li>
</ul></li>
</ul>
<ul>
<li>接收新数据，更新组件
<ul>
<li><p>组件自身<code>setState</code>的更新：</p>
<ul>
<li><code>shouldComponentUpdate</code>： 能拿到要更新的<code>props</code>和<code>state</code>， 根据业务需求，可以进行判断，返回<code>false</code>即不更新， 这里可以做一个性能调优的处理。</li>
<li><code>componentWillUpdate</code>： 组件即将更新，这里不能使用<code>setState</code></li>
<li><code>render</code></li>
<li><code>componentDidUpdate</code></li>
</ul></li>
<li><p>父组件<code>props</code>改变的更新：</p>
<ul>
<li><code>componentWillReceiveProps</code>：接受到<code>props</code>新的属性，这里可以跟<code>this.props.属性</code>比较做一些判断，在更新之前还有一次<code>setState</code>的机会</li>
<li><code>shouldComponentUpdate</code></li>
<li><code>componentWillUpdate</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>render</code></li>
<li><code>componentDidUpdate</code></li>
</ul></li>
</ul></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next" href="/liuxiaobai/blog/page2/">Next →</a></div></div></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'my-api-key',
                indexName: 'my-index-name',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>