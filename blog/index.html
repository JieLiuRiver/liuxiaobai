<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blog · 柳小白</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Be Water, My Friend!"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blog · 柳小白"/><meta property="og:type" content="website"/><meta property="og:url" content="https://github.com/stupidWall/liuxiaobai/liuxiaobai/"/><meta property="og:description" content="Be Water, My Friend!"/><meta property="og:image" content="https://github.com/stupidWall/liuxiaobai/liuxiaobai/img/1.jpeg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://github.com/stupidWall/liuxiaobai/liuxiaobai/img/1.jpeg"/><link rel="shortcut icon" href="/liuxiaobai/"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night.min.css"/><link rel="alternate" type="application/atom+xml" href="https://github.com/stupidWall/liuxiaobai/liuxiaobai/blog/atom.xml" title="柳小白 Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://github.com/stupidWall/liuxiaobai/liuxiaobai/blog/feed.xml" title="柳小白 Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/liuxiaobai/js/scrollSpy.js"></script><link rel="stylesheet" href="/liuxiaobai/css/main.css"/><script src="/liuxiaobai/js/codetabs.js"></script></head><body class="blog"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/liuxiaobai/"><h2 class="headerTitle">柳小白</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/liuxiaobai/blog/" target="_self">Blog</a></li><li class=""><a href="https://github.com/stupidWall/liuxiaobai" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>All Blog Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">All Blog Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2020/08/21/vue">iview</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2020/08/15/对象转内联样式">对象转内联样式</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/09/08/linklist">实现链表并应用</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/09/05/stack">实现栈并应用</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/09/05/queue">实现队列并应用</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/27/jsonp">实现一个JSONP</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/26/柯里化">柯里化</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/26/实现一个Promise">实现一个Promise</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/26/实现instanceof">实现一个instanceof</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/14/Object.assign">模拟实现Object.assign</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/14/TypeScript">TypeScript</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/12/utils">收集开源项目好用工具函数</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/12/TaroUi">taro-ui</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/11/events">读Taro消息机制源码笔记</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/10/面试题">火爆了的前端面试题</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/泛型">泛型（TypeScript学习笔记）</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/格式化日期">格式化日期</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/枚举">枚举（TypeScript学习笔记）</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/react生命周期">React生命周期</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/parseStyle">内联样式转对象</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/05/驼峰">中横线转驼峰变量</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2020/08/21/vue">iview</a></h1><p class="post-meta">August 21, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="动态组件"></a><a href="#动态组件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>动态组件</h3>
<pre><code class="hljs css language-javascript">&lt;component :is=<span class="hljs-string">"wrapperComponent"</span>&gt;
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span>

...

computed: {
  wrapperComponent() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.affix ? <span class="hljs-string">'Affix'</span> : <span class="hljs-string">'div'</span>;
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="provide-依赖注入"></a><a href="#provide-依赖注入" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>provide 依赖注入</h3>
<p>由于使用 <code>$parent</code> 属性无法很好的扩展到更深层级的嵌套组件上</p>
<p>vue提供了新的实例选项：provide 和 inject</p>
<p>父组件</p>
<pre><code class="hljs css language-javascript">provide () {
  <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">anchorCom</span>: <span class="hljs-keyword">this</span>
  };
}
</code></pre>
<p>子组件</p>
<pre><code class="hljs css language-javascript">inject: ['anchorCom']

# 使用
this.anchorCom.xxx
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="匹配锚点"></a><a href="#匹配锚点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>匹配锚点</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> reg =  <span class="hljs-regexp">/#([^#]+)$/</span>
<span class="hljs-keyword">var</span> match = reg.exec(<span class="hljs-string">'https://www.iviewui.com/components/anchor#AnchorLink_props'</span>)

<span class="hljs-comment">// match</span>
[
  <span class="hljs-string">'#AnchorLink_props'</span>,
  <span class="hljs-string">'AnchorLink_props'</span>,
  ...
]
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="节点元素滚动动画"></a><a href="#节点元素滚动动画" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>节点元素滚动动画</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scrollTop</span>(<span class="hljs-params">el, from = <span class="hljs-number">0</span>, to, duration = <span class="hljs-number">500</span>, endCallback</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.requestAnimationFrame) {
        <span class="hljs-built_in">window</span>.requestAnimationFrame = (
            <span class="hljs-built_in">window</span>.webkitRequestAnimationFrame ||
            <span class="hljs-built_in">window</span>.mozRequestAnimationFrame ||
            <span class="hljs-built_in">window</span>.msRequestAnimationFrame ||
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.setTimeout(callback, <span class="hljs-number">1000</span>/<span class="hljs-number">60</span>);
            }
        );
    }
    <span class="hljs-keyword">const</span> difference = <span class="hljs-built_in">Math</span>.abs(<span class="hljs-keyword">from</span> - to);
    <span class="hljs-keyword">const</span> step = <span class="hljs-built_in">Math</span>.ceil(difference / duration * <span class="hljs-number">50</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scroll</span>(<span class="hljs-params">start, end, step</span>) </span>{
        <span class="hljs-keyword">if</span> (start === end) {
            endCallback &amp;&amp; endCallback();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">let</span> d = (start + step &gt; end) ? end : start + step;
        <span class="hljs-keyword">if</span> (start &gt; end) {
            d = (start - step &lt; end) ? end : start - step;
        }

        <span class="hljs-keyword">if</span> (el === <span class="hljs-built_in">window</span>) {
            <span class="hljs-built_in">window</span>.scrollTo(d, d);
        } <span class="hljs-keyword">else</span> {
            el.scrollTop = d;
        }
        <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> scroll(d, end, step));
    }
    scroll(<span class="hljs-keyword">from</span>, to, step);
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="通信"></a><a href="#通信" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>通信</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">broadcast</span>(<span class="hljs-params">componentName, eventName, params</span>) </span>{
    <span class="hljs-keyword">this</span>.$children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> name = child.$options.name;

        <span class="hljs-keyword">if</span> (name === componentName) {
            child.$emit.apply(child, [eventName].concat(params));
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// todo 如果 params 是空数组，接收到的会是 undefined</span>
            broadcast.apply(child, [componentName, eventName].concat([params]));
        }
    });
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">methods</span>: {
        dispatch(componentName, eventName, params) {
            <span class="hljs-keyword">let</span> parent = <span class="hljs-keyword">this</span>.$parent || <span class="hljs-keyword">this</span>.$root;
            <span class="hljs-keyword">let</span> name = parent.$options.name;

            <span class="hljs-keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) {
                parent = parent.$parent;

                <span class="hljs-keyword">if</span> (parent) {
                    name = parent.$options.name;
                }
            }
            <span class="hljs-keyword">if</span> (parent) {
                parent.$emit.apply(parent, [eventName].concat(params));
            }
        },
        broadcast(componentName, eventName, params) {
            broadcast.call(<span class="hljs-keyword">this</span>, componentName, eventName, params);
        }
    }
};
</code></pre>
<p>使用</p>
<pre><code class="hljs css language-javascript">mixins: [ Emitter ]
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="传入v-model到组件内部"></a><a href="#传入v-model到组件内部" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>传入v-model到组件内部</h3>
<pre><code class="hljs css language-javascript">props: {
    <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">type</span>: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Number</span>],
        <span class="hljs-attr">default</span>: <span class="hljs-string">''</span>
    }
},
data () {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">currentVal</span>: <span class="hljs-keyword">this</span>.value
    }
},
<span class="hljs-attr">watch</span>: {
    value (val) {
        <span class="hljs-keyword">this</span>.currentVal = val
    }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="获取元素布局信息"></a><a href="#获取元素布局信息" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>获取元素布局信息</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">this</span>.$el.getBoundingClientRect()
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="回到顶部组件"></a><a href="#回到顶部组件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>回到顶部组件</h3>
<p>当滚动高度大于等于100时， 显示回到顶部按钮</p>
<p><img src="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/pageYOffset" alt="pageYOffset"></p>
<pre><code class="hljs css language-javascript"><span class="hljs-built_in">window</span>.pageYOffset &gt;= <span class="hljs-number">100</span>
</code></pre>
<p>获取<code>window</code>滚动的高度</p>
<pre><code class="hljs css language-javascript"><span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2020/08/15/对象转内联样式">对象转内联样式</a></h1><p class="post-meta">August 15, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="源码链接"></a><a href="#源码链接" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码链接</h3>
<p><a href="https://github.com/NervJS/taro/blob/master/packages/taro/src/internal/inline-style.js">跳转</a></p>
<h3><a class="anchor" aria-hidden="true" id="代码"></a><a href="#代码" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> upperCasePattern = <span class="hljs-regexp">/([A-Z])/g</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dashify</span> (<span class="hljs-params">str</span>) </span>{
  <span class="hljs-keyword">return</span> str.replace(upperCasePattern, dashLower)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dashLower</span> (<span class="hljs-params">c</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'-'</span> + c.toLowerCase()
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">return</span> val != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-built_in">Array</span>.isArray(val) === <span class="hljs-literal">false</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inlineStyle</span> (<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">return</span> obj
  }

  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || obj === <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
  }

  <span class="hljs-keyword">if</span> (!isObject(obj)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'style 只能是一个对象或字符串。'</span>)
  }
  <span class="hljs-comment">// [{backgroundColor: 'red'}] =&gt; 'background-color:red;'</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(obj).map(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> dashify(key).concat(<span class="hljs-string">':'</span>).concat(obj[key])).join(<span class="hljs-string">';'</span>)

}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="测试"></a><a href="#测试" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>测试</h3>
<p><img src="https://raw.githubusercontent.com/stupidWall/liuxiaobai/master/img/blog/2019/20190814115913.jpg" /></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/09/08/linklist">实现链表并应用</a></h1><p class="post-meta">September 8, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="定义"></a><a href="#定义" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定义</h3>
<ul>
<li><p>猴子捞月</p></li>
<li><p>节点组成</p>
<ul>
<li>节点分为： 数据 ； 下一个的指针</li>
</ul></li>
<li><p>有首节点、尾节点</p></li>
</ul>
<blockquote>
<p>分析</p>
</blockquote>
<pre><code class="hljs"><span class="hljs-type">A</span>(  
    <span class="hljs-class"><span class="hljs-keyword">data</span>,</span>
    next =&gt; <span class="hljs-type">B</span>   
)

<span class="hljs-type">B</span>(  
    <span class="hljs-class"><span class="hljs-keyword">data</span>,</span>
    next =&gt; <span class="hljs-type">C</span>
)

<span class="hljs-type">C</span>(  
    <span class="hljs-class"><span class="hljs-keyword">data</span>,</span>
    next =&gt; <span class="hljs-type">D</span>
)

<span class="hljs-type">D</span>(  
    <span class="hljs-class"><span class="hljs-keyword">data</span>,</span>
    next =&gt; <span class="hljs-type">E</span>
)

</code></pre>
<h4><a class="anchor" aria-hidden="true" id="添加元素a"></a><a href="#添加元素a" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>添加元素A</h4>
<ul>
<li><p>如果一个都还没有：
头节点 = 新添加的A
尾节点 = 头节点
链表长度+1</p></li>
<li><p>如果已经有了
尾节点.next = A
尾节点 = A
链表长度+1</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="在b节点处插入m节点"></a><a href="#在b节点处插入m节点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在B节点处插入M节点</h4>
<ul>
<li><p>如果B节点是最后一个，相当于往后往后添加一个M，使用上面的方法</p></li>
<li><p>如果B节点是第一个，即头部追加一个M, 这个时候M.next = B; head = M</p></li>
<li><p>如果B节点位置在首尾部之间： 知道B索引为1， 我要拿到B节点，然后B.next节点 = M， 同时M.next应该是原来的B.next，这样才能衔接上，所以要把原来B.next变量存储一下</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="移除指定c节点"></a><a href="#移除指定c节点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>移除指定C节点</h4>
<ul>
<li><p>位置值index</p></li>
<li><p>判断index是否在有效位置区间</p></li>
<li><p>找到C节点，找到C节点的上一个节点B</p></li>
<li><p>B.next 应该等于 C.next</p></li>
<li><p>C.next 应该释放掉 = null</p></li>
<li><p>c.data 删掉</p></li>
<li><p>注意，如果删除的是尾节点D, 需要把tail更改为C</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="返回制定位置的节点数据"></a><a href="#返回制定位置的节点数据" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>返回制定位置的节点数据</h4>
<ul>
<li><p>知道位置index</p></li>
<li><p>从0开始排查</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="根据节点数据data-返回位置"></a><a href="#根据节点数据data-返回位置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>根据节点数据data, 返回位置</h4>
<ul>
<li><p>从头节点开始排查</p></li>
<li><p>直到data === data, 拿到位置值返回</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="清空链表"></a><a href="#清空链表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>清空链表</h4>
<ul>
<li>头节点、尾节点 = null</li>
<li>长度 = 0</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="输出打印链表"></a><a href="#输出打印链表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>输出打印链表</h4>
<ul>
<li>每一个节点的data, 拼接打印出来</li>
</ul>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkList</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// 定义节点</span>
    <span class="hljs-keyword">var</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
        <span class="hljs-keyword">this</span>.data = data;
        <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> length = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 长度</span>
    <span class="hljs-keyword">var</span> head = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 头节点</span>
    <span class="hljs-keyword">var</span> tail = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 尾节点</span>

    <span class="hljs-comment">// 添加一个新元素</span>
    <span class="hljs-keyword">this</span>.append = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
        <span class="hljs-comment">// 创建新节点</span>
        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(data);
        <span class="hljs-comment">// 如果是空链表</span>
        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>){
            head = node;
            tail = head;
        }<span class="hljs-keyword">else</span>{
            tail.next = node;       <span class="hljs-comment">// 尾节点指向新创建的节点</span>
            tail = node;            <span class="hljs-comment">// tail指向链表的最后一个节点</span>
        }
        length += <span class="hljs-number">1</span>;                <span class="hljs-comment">// 长度加1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };

    <span class="hljs-comment">// 返回链表大小</span>
    <span class="hljs-keyword">this</span>.length = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> length;
    };

    <span class="hljs-comment">// 在指定位置插入新的元素</span>
    <span class="hljs-keyword">this</span>.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, data</span>)</span>{
        <span class="hljs-keyword">if</span>(index == length){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.append(data);
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index &gt; length || index &lt; <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">var</span> new_node = <span class="hljs-keyword">new</span> Node(data);
            <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>){
                new_node.next= head;
                head = new_node;
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">var</span> insert_index = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">var</span> curr_node = head;
                <span class="hljs-comment">// 找到应该插入的位置</span>
                <span class="hljs-keyword">while</span>(insert_index &lt; index){
                    curr_node = curr_node.next;
                    insert_index += <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">var</span> next_node = curr_node.next;
                curr_node.next = new_node;
                new_node.next = next_node;
            }
            length += <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    };

    <span class="hljs-comment">// 删除指定位置的节点</span>
    <span class="hljs-keyword">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>)</span>{
        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= length){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">var</span> del_node = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>){
                <span class="hljs-comment">// head指向下一个节点</span>
                del_node = head;
                head = head.next;
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">var</span> del_index = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">var</span> pre_node = <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">var</span> curr_node = head;
                <span class="hljs-keyword">while</span>(del_index &lt; index){
                    del_index += <span class="hljs-number">1</span>;
                    pre_node = curr_node;
                    curr_node =curr_node.next;
                }
                del_node = curr_node;
                pre_node.next = curr_node.next;
                <span class="hljs-comment">// 如果删除的是尾节点</span>
                <span class="hljs-keyword">if</span>(curr_node.next==<span class="hljs-literal">null</span>){
                    tail = pre_node;
                }
            }
            length -= <span class="hljs-number">1</span>;
            del_node.next = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span> del_node.data;
        }
    };

    <span class="hljs-comment">// 删除尾节点</span>
    <span class="hljs-keyword">this</span>.remove_tail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.remove(length<span class="hljs-number">-1</span>);
    };

    <span class="hljs-comment">// 删除头节点</span>
    <span class="hljs-keyword">this</span>.remove_head = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.remove(<span class="hljs-number">0</span>);
    };

    <span class="hljs-comment">// 返回指定位置节点的值</span>
    <span class="hljs-keyword">this</span>.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>)</span>{
        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= length){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">var</span> node_index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> curr_node = head;
        <span class="hljs-keyword">while</span>(node_index &lt; index){
            node_index += <span class="hljs-number">1</span>;
            curr_node = curr_node.next;
        }
        <span class="hljs-keyword">return</span> curr_node.data;
    };

    <span class="hljs-comment">// 返回链表头节点的值</span>
    <span class="hljs-keyword">this</span>.head = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(<span class="hljs-number">0</span>);
    }

    <span class="hljs-comment">// 返回链表尾节点的值</span>
    <span class="hljs-keyword">this</span>.tail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(length<span class="hljs-number">-1</span>);
    }

    <span class="hljs-comment">// 返回指定元素的索引,如果没有,返回-1</span>
    <span class="hljs-comment">// 有多个相同元素,返回第一个</span>
    <span class="hljs-keyword">this</span>.indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
        <span class="hljs-keyword">var</span> index = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">var</span> curr_node = head;
        <span class="hljs-keyword">while</span>(curr_node){
            index += <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span>(curr_node.data == data){
                <span class="hljs-keyword">return</span> index;
            }<span class="hljs-keyword">else</span>{
                curr_node = curr_node.next;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    };

    <span class="hljs-comment">// 输出链表</span>
    <span class="hljs-keyword">this</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">var</span> curr_node = head;
        <span class="hljs-keyword">var</span> str_link = <span class="hljs-string">""</span>
        <span class="hljs-keyword">while</span>(curr_node){

            str_link += curr_node.data.toString() + <span class="hljs-string">" -&gt;"</span>;
            curr_node = curr_node.next;
        }
        str_link += <span class="hljs-string">"null"</span>;
        <span class="hljs-built_in">console</span>.log(str_link);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"长度为"</span>+ length.toString());
    };

    <span class="hljs-comment">// isEmpty</span>
    <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> length == <span class="hljs-number">0</span>;
    };

    <span class="hljs-comment">// 清空链表</span>
    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        head = <span class="hljs-literal">null</span>;
        tail = <span class="hljs-literal">null</span>;
        length = <span class="hljs-number">0</span>;
    };

};

exports.LinkList = LinkList;

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="使用链表实现栈"></a><a href="#使用链表实现栈" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用链表实现栈</h3>
<pre><code class="hljs css language-javascript">LinkList = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./mylinklist"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> linklist = <span class="hljs-keyword">new</span> LinkList.LinkList();

    <span class="hljs-comment">// 从栈顶添加元素</span>
    <span class="hljs-keyword">this</span>.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{
        linklist.append(item);
    };

    <span class="hljs-comment">// 弹出栈顶元素</span>
    <span class="hljs-keyword">this</span>.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.remove_tail();
    };

    <span class="hljs-comment">// 返回栈顶元素</span>
    <span class="hljs-keyword">this</span>.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.tail();
    };

    <span class="hljs-comment">// 返回栈的大小</span>
    <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.length();
    };

    <span class="hljs-comment">// 判断是否为空</span>
    <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.isEmpty();
    };

    <span class="hljs-comment">// 清空栈</span>
    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        linklist.clear()
    };
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="使用链表实现队列"></a><a href="#使用链表实现队列" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用链表实现队列</h3>
<pre><code class="hljs css language-javascript">
LinkList = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./mylinklist"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> linklist = <span class="hljs-keyword">new</span> LinkList.LinkList();

    <span class="hljs-comment">// 入队列</span>
    <span class="hljs-keyword">this</span>.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{
        linklist.append(item);
    };

    <span class="hljs-comment">// 出队列</span>
    <span class="hljs-keyword">this</span>.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.remove_head();
    };

    <span class="hljs-comment">// 返回队首</span>
    <span class="hljs-keyword">this</span>.head = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.head();
    };

    <span class="hljs-comment">// 返回队尾</span>
    <span class="hljs-keyword">this</span>.tail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.tail();
    };

    <span class="hljs-comment">// size</span>
    <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.length();
    };

    <span class="hljs-comment">//clear</span>
    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        linklist.clear();
    };

    <span class="hljs-comment">// isEmpty</span>
    <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.isEmpty();
    };
};


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n</span>)</span>{
    queue = <span class="hljs-keyword">new</span> Queue();
    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 先放入斐波那契序列的前两个数值</span>
    queue.enqueue(<span class="hljs-number">1</span>);
    queue.enqueue(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">while</span>(index &lt; n<span class="hljs-number">-2</span>){
        <span class="hljs-comment">// 出队列一个元素</span>
        <span class="hljs-keyword">var</span> del_item = queue.dequeue();
        <span class="hljs-comment">// 取队列头部元素</span>
        <span class="hljs-keyword">var</span> head_item = queue.head();
        <span class="hljs-keyword">var</span> next_item = del_item + head_item;
        <span class="hljs-comment">// 将计算结果放入队列</span>
        queue.enqueue(next_item);
        index += <span class="hljs-number">1</span>;
    }
    queue.dequeue();
    <span class="hljs-keyword">return</span> queue.head();
};

<span class="hljs-built_in">console</span>.log(fibonacci(<span class="hljs-number">8</span>));

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="翻转链表"></a><a href="#翻转链表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>翻转链表</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">var</span> node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> node3 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">3</span>);
<span class="hljs-keyword">var</span> node4 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">4</span>);
<span class="hljs-keyword">var</span> node5 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">5</span>);


node1.next = node2;
node2.next = node3;
node3.next = node4;
node4.next = node5;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">node</span>)</span>{
    <span class="hljs-keyword">var</span> curr_node = node;
    <span class="hljs-keyword">while</span>(curr_node){
        <span class="hljs-built_in">console</span>.log(curr_node.data);
        curr_node = curr_node.next;
    }
};
</code></pre>
<p><code>A =&gt; B =&gt; C =&gt; D</code></p>
<p><code>=&gt;</code></p>
<p><code>D =&gt; C =&gt; B =&gt; A</code></p>
<h4><a class="anchor" aria-hidden="true" id="迭代实现"></a><a href="#迭代实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>迭代实现</h4>
<blockquote>
<p>思路分析</p>
</blockquote>
<ul>
<li>首节点<code>A</code></li>
</ul>
<pre><code class="hljs css language-javascript">    A.next = 默认一个<span class="hljs-literal">null</span>

    结果： A
</code></pre>
<ul>
<li>节点<code>B</code></li>
</ul>
<pre><code class="hljs css language-javascript">    B.next = A(这个A怎么来， 上一轮迭代的<span class="hljs-literal">null</span>，改为A)
    结果： B =&gt; A
</code></pre>
<ul>
<li>节点<code>C</code></li>
</ul>
<pre><code class="hljs css language-javascript">    C.next = B(这个B怎么来， 上一轮迭代的A，改为B)
    结果：C =&gt; <span class="hljs-function"><span class="hljs-params">B</span> =&gt;</span> A
</code></pre>
<p>...</p>
<p>最终结果： <code>D =&gt; C =&gt; B =&gt; A</code></p>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript">
<span class="hljs-comment">// 迭代翻转</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse_iter</span>(<span class="hljs-params">head</span>)</span>{
    <span class="hljs-keyword">if</span>(!head){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">var</span> pre_node = <span class="hljs-literal">null</span>;     <span class="hljs-comment">// 前一个节点</span>
    <span class="hljs-keyword">var</span> curr_node = head;    <span class="hljs-comment">// 当前要翻转的节点</span>
    <span class="hljs-keyword">while</span>(curr_node){
        <span class="hljs-keyword">var</span> next_node = curr_node.next;    <span class="hljs-comment">// 下一个节点</span>
        curr_node.next = pre_node;         <span class="hljs-comment">// 对当前节点进行翻转</span>
        pre_node = curr_node;              <span class="hljs-comment">// pre_node向后滑动</span>
        curr_node = next_node;             <span class="hljs-comment">// curr_node向后滑动</span>
    }
    <span class="hljs-comment">//最后要返回pre_node,当循环结束时,pre_node指向翻转前链表的最后一个节点</span>
    <span class="hljs-keyword">return</span> pre_node;
};

print(reverse_digui(node1));
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="从尾到头打印链表"></a><a href="#从尾到头打印链表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从尾到头打印链表</h4>
<ul>
<li>不能翻转链表</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse_print</span>(<span class="hljs-params">head</span>)</span>{
    <span class="hljs-comment">// 递归终止条件</span>
    <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>
    } <span class="hljs-keyword">else</span> {
        reverse_print(head.next);  <span class="hljs-comment">// 全部打印完后</span>
        <span class="hljs-built_in">console</span>.log(head.data); <span class="hljs-comment">// 打印头节点</span>
    }
};
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="合并2个有序的链表"></a><a href="#合并2个有序的链表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>合并2个有序的链表</h4>
<p>链表<code>A</code>：</p>
<p><code>1 =&gt; 4 =&gt; 6</code></p>
<p>链表<code>B</code>：</p>
<p><code>2 =&gt; 5 =&gt; 7 =&gt; 9</code></p>
<p>输出</p>
<p><code>1 =&gt; 2 =&gt; 4 =&gt; 5 =&gt; 6 =&gt; 8 =&gt; 9</code></p>
<blockquote>
<p>思路</p>
</blockquote>
<ul>
<li><p>链表<code>A</code>，链表<code>B</code>同步“循环”， 一一比较</p></li>
<li><p><code>1</code> &lt; <code>2</code>, 取<code>1</code>, 作为新链表<code>C</code>的头节点、尾节点</p></li>
<li><p><code>1</code>被取过了， 迭代到<code>1</code>.next， 即<code>4</code></p></li>
<li><p><code>4</code> &lt; <code>2</code>， 取<code>2</code>, 作为<code>c</code>链表尾节点.next节点</p></li>
<li><p>...</p></li>
<li><p><code>A</code>链表长度跟<code>B</code>链表的不一样，最后<code>A</code>的<code>6</code>被取走，留<code>B</code>的<code>7</code>、<code>9</code></p></li>
<li><p>找到<code>7</code>, 再来一次迭代，依次<code>push</code>到<code>C</code>链表的<code>tail</code></p></li>
<li><p>返回<code>C</code>链表</p></li>
</ul>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge_link</span>(<span class="hljs-params">head1, head2</span>)</span>{
    <span class="hljs-keyword">if</span>(head1 == <span class="hljs-literal">null</span>){
        <span class="hljs-keyword">return</span> head2;
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head2 == <span class="hljs-literal">null</span>){
        <span class="hljs-keyword">return</span> head1;
    }

    <span class="hljs-keyword">var</span> merge_head = <span class="hljs-literal">null</span>;   <span class="hljs-comment">// 合并后链表头</span>
    <span class="hljs-keyword">var</span> merge_tail = <span class="hljs-literal">null</span>;   <span class="hljs-comment">// 合并后链表尾</span>
    <span class="hljs-keyword">var</span> curr_1 = head1;
    <span class="hljs-keyword">var</span> curr_2 = head2;
    <span class="hljs-keyword">while</span>(curr_1 &amp;&amp; curr_2){
        <span class="hljs-comment">// 找到最小值</span>
        <span class="hljs-keyword">var</span> min_data;
        <span class="hljs-keyword">if</span>(curr_1.data &lt; curr_2.data) {
            min_data = curr_1.data;
            curr_1 = curr_1.next;
        }<span class="hljs-keyword">else</span>{
            min_data = curr_2.data;
            curr_2 = curr_2.next;
        }
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'min_data'</span>, min_data)

        <span class="hljs-keyword">if</span>(merge_head == <span class="hljs-literal">null</span>){
            merge_head = <span class="hljs-keyword">new</span> Node(min_data);
            merge_tail = merge_head;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">var</span> new_node = <span class="hljs-keyword">new</span> Node(min_data);
            <span class="hljs-comment">// 把new_node连接到合并链表</span>
            merge_tail.next = new_node;
            <span class="hljs-comment">// 尾节点指向新创建的节点</span>
            merge_tail = new_node;
        }

    }

    <span class="hljs-comment">// 链表可能还有一部分没有合并进来</span>
    <span class="hljs-keyword">var</span> rest_link = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span>(curr_1){
        rest_link = curr_1;
    }
    <span class="hljs-keyword">if</span>(curr_2){
        rest_link = curr_2;
    }

    <span class="hljs-keyword">while</span>(rest_link){
        <span class="hljs-keyword">var</span> new_node = <span class="hljs-keyword">new</span> Node(rest_link.data);
        merge_tail.next = new_node;
        merge_tail = new_node;
        rest_link = rest_link.next;
    }
    <span class="hljs-keyword">return</span> merge_head;
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="查找单链表中的倒数第idx个节点"></a><a href="#查找单链表中的倒数第idx个节点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找单链表中的倒数第idx个节点</h4>
<p><code>A =&gt; B =&gt; C =&gt; D =&gt; E</code></p>
<p><code>idx = 2</code></p>
<p>输出： <code>D</code></p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">var</span> node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'A'</span>);
<span class="hljs-keyword">var</span> node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'B'</span>);
<span class="hljs-keyword">var</span> node3 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'C'</span>);
<span class="hljs-keyword">var</span> node4 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'D'</span>);
<span class="hljs-keyword">var</span> node5 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'E'</span>);


node1.next = node2
node2.next = node3
node3.next = node4
node4.next = node5


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse_find</span>(<span class="hljs-params">head, idx</span>)</span>{
  <span class="hljs-keyword">let</span> cur_node = head
  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (cur_node) {
    len += <span class="hljs-number">1</span>
    cur_node = cur_node.next
  }
  <span class="hljs-keyword">if</span> (idx &gt;= len) {
    <span class="hljs-keyword">return</span> head
  }
  <span class="hljs-keyword">let</span> resetIdx = len - idx
  cur_node = head
  <span class="hljs-keyword">while</span> (resetIdx) {
    cur_node = cur_node.next
    resetIdx -= <span class="hljs-number">1</span>
  }
  <span class="hljs-keyword">return</span> cur_node
}

<span class="hljs-built_in">console</span>.log(
  reverse_find(node1, <span class="hljs-number">2</span>)
)
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="查找单链表中间节点"></a><a href="#查找单链表中间节点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找单链表中间节点</h4>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">var</span> node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'A'</span>);
<span class="hljs-keyword">var</span> node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'B'</span>);
<span class="hljs-keyword">var</span> node3 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'C'</span>);
<span class="hljs-keyword">var</span> node4 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'D'</span>);
<span class="hljs-keyword">var</span> node5 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'E'</span>);


node1.next = node2
node2.next = node3
node3.next = node4
node4.next = node5


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find_middle</span>(<span class="hljs-params">head</span>)</span>{
  <span class="hljs-keyword">let</span> cur_node = head
  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (cur_node) {
    len += <span class="hljs-number">1</span>
    cur_node = cur_node.next
  }
  <span class="hljs-keyword">let</span> midIdx = <span class="hljs-built_in">Math</span>.ceil(len / <span class="hljs-number">2</span>)
  cur_node = head
  <span class="hljs-keyword">while</span> (--midIdx) {
    cur_node = cur_node.next
  }
  <span class="hljs-keyword">return</span> cur_node
}

<span class="hljs-built_in">console</span>.log(
  find_middle(node1)
)
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/09/05/stack">实现栈并应用</a></h1><p class="post-meta">September 5, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="栈的特性"></a><a href="#栈的特性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>栈的特性</h3>
<ul>
<li>只能从栈顶操作</li>
<li>先进的后出</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="数组实现"></a><a href="#数组实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数组实现</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 使用数组存储数据</span>
    <span class="hljs-keyword">var</span> items = [];  

    <span class="hljs-comment">// push方法向栈里压入一个元素</span>
    <span class="hljs-keyword">this</span>.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{
        items.push(item);
    };

    <span class="hljs-comment">// pop方法把栈顶的元素弹出</span>
    <span class="hljs-keyword">this</span>.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> items.pop();
    };

    <span class="hljs-comment">// top 方法返回栈顶元素</span>
    <span class="hljs-keyword">this</span>.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> items[items.length - <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">// isEmpty返回栈是否为空</span>
    <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> items.length == <span class="hljs-number">0</span>;
    };

    <span class="hljs-comment">// size方法返回栈的大小</span>
    <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> items.length;
    };

    <span class="hljs-comment">// clear 清空栈</span>
    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        items = []
    };
}
exports.Stack = Stack;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="应用"></a><a href="#应用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用</h3>
<h4><a class="anchor" aria-hidden="true" id="利用栈的进栈出栈存储数据-做业务判断"></a><a href="#利用栈的进栈出栈存储数据-做业务判断" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用栈的进栈出栈存储数据，做业务判断</h4>
<p>合法括号</p>
<p><code>dfdsf(r23)</code> 合法</p>
<p><code>dfdsf(r23))</code> 不合法</p>
<blockquote>
<p>思路</p>
</blockquote>
<ul>
<li>遍历</li>
<li>若是<code>(</code>，进栈； <code>['(']</code></li>
<li>若是<code>)</code>, 若栈中有<code>(</code>, 出栈抵消掉，栈又变成空栈<code>[]</code>； 若栈中无<code>(</code>，抵消不了；</li>
<li>遍历完成，最理想的情况，全部成双抵消，栈为空</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="利用栈弹出的都是最新压入栈的数据-即后进先出特点"></a><a href="#利用栈弹出的都是最新压入栈的数据-即后进先出特点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用栈弹出的都是最新压入栈的数据，即后进先出特点</h4>
<p>逆波兰表达式</p>
<p><code>[&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</code></p>
<p>相当于</p>
<p><code>(10 * (6 / (((9 + 3) * -11))) + 17) + 5</code></p>
<blockquote>
<p>思路</p>
</blockquote>
<ul>
<li><p>实例出来一个栈</p></li>
<li><p>遍历数组</p>
<pre><code class="hljs">入栈:
[<span class="hljs-number">10</span>]
[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>]
[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>]
[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>]
</code></pre></li>
<li><p>遇到<code>+</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">3</span>
弹出<span class="hljs-number">9</span>
栈：[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>]
<span class="hljs-number">9</span> + <span class="hljs-number">3</span> = <span class="hljs-number">12</span>
入栈
栈：[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>]
</code></pre></li>
<li><p>继续</p>
<pre><code class="hljs">[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>， <span class="hljs-number">-11</span>]
</code></pre></li>
</ul>
<ul>
<li><p>遇到<code>*</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">-11</span>
弹出<span class="hljs-number">12</span>
栈： [<span class="hljs-number">10</span>, <span class="hljs-number">6</span>]
计算<span class="hljs-number">12</span> * <span class="hljs-number">-11</span> = <span class="hljs-number">-132</span>
入栈
栈：[<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-132</span>]
</code></pre></li>
<li><p>遇到<code>/</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">-132</span>
弹出<span class="hljs-number">6</span>
栈：[<span class="hljs-number">10</span>]
<span class="hljs-number">6</span> / <span class="hljs-number">-132</span> = <span class="hljs-number">-0.45</span>
进栈
栈：[<span class="hljs-number">10</span>， <span class="hljs-number">-0.45</span>]
</code></pre></li>
<li><p>遇到<code>*</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">-0.45</span>
弹出<span class="hljs-number">10</span>
栈：[]
<span class="hljs-number">10</span> * <span class="hljs-number">-0.45</span> = <span class="hljs-number">-4.5</span>
进栈
栈：[<span class="hljs-number">-4.5</span>]
</code></pre></li>
</ul>
<ul>
<li>继续
<pre><code class="hljs">栈：[<span class="hljs-number">-4.5</span>, <span class="hljs-number">17</span>]
</code></pre></li>
</ul>
<ul>
<li><p>遇到<code>+</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">17</span>
弹出<span class="hljs-number">-4.5</span>
栈：[]
<span class="hljs-number">-4.5</span> + <span class="hljs-number">17</span> = <span class="hljs-number">12.5</span>
进栈
栈：[<span class="hljs-number">12.5</span>]
</code></pre></li>
<li><p>继续</p>
<pre><code class="hljs">栈：[<span class="hljs-number">12.5</span>, <span class="hljs-number">5</span>]
</code></pre></li>
<li><p>遇到<code>+</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">5</span>
弹出<span class="hljs-number">12.5</span>
栈：[]
<span class="hljs-number">12.5</span> + <span class="hljs-number">5</span> = <span class="hljs-number">17.5</span>
进栈
栈：[<span class="hljs-number">17.5</span>]
</code></pre></li>
<li><p>出栈<code>17.5</code></p></li>
</ul>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calc_exp</span>(<span class="hljs-params">exp</span>)</span>{
    <span class="hljs-keyword">var</span> stack = <span class="hljs-keyword">new</span> Stack();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; exp.length;i++){
        <span class="hljs-keyword">var</span> item = exp[i];

        <span class="hljs-keyword">if</span>([<span class="hljs-string">"+"</span>, <span class="hljs-string">"-"</span>, <span class="hljs-string">"*"</span>, <span class="hljs-string">"/"</span>].indexOf(item) &gt;= <span class="hljs-number">0</span>){
            <span class="hljs-comment">// 从栈顶弹出两个元素</span>
            <span class="hljs-keyword">var</span> value_1 = stack.pop();
            <span class="hljs-keyword">var</span> value_2 = stack.pop();
            <span class="hljs-comment">// 拼成表达式</span>
            <span class="hljs-keyword">var</span> exp_str = value_2 + item + value_1;
            <span class="hljs-comment">// 计算并取整</span>
            <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">eval</span>(exp_str));
            <span class="hljs-comment">// 将计算结果压如栈</span>
            stack.push(res.toString());
        }<span class="hljs-keyword">else</span>{
            stack.push(item);
        }
    }
    <span class="hljs-comment">// 表达式如果是正确的,最终,栈里还有一个元素,且正是表达式的计算结果</span>
    <span class="hljs-keyword">return</span> stack.pop();
};
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="利用栈顶弹出实现最小值"></a><a href="#利用栈顶弹出实现最小值" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用栈顶弹出实现最小值</h4>
<p>有一种需求，比较最大值或最小值，通过栈的方式来实现比较</p>
<blockquote>
<p>思路</p>
</blockquote>
<ul>
<li><p>实例一个专门存最大或最小的栈A</p></li>
<li><p>遍历一个已知数组</p></li>
<li><p>只要保证栈A的栈顶一直是最小的值即可(每一个都跟栈顶比较)</p></li>
<li><p>遍历完成，弹出栈A栈顶值</p></li>
</ul>
<blockquote>
<p>演示</p>
</blockquote>
<p><code>[5, 2, 4, 8, 1, 4, 7]</code></p>
<ul>
<li><p><code>5:</code> <code>A[5]</code></p></li>
<li><p><code>2:</code> <code>A[5, 2]</code></p></li>
<li><p><code>4:</code> <code>A[5, 2]</code></p></li>
<li><p><code>8:</code> <code>A[5, 2]</code></p></li>
<li><p><code>1:</code> <code>A[5, 2, 1]</code></p></li>
<li><p><code>4:</code> <code>A[5, 2, 1]</code></p></li>
<li><p><code>7:</code> <code>A[5, 2, 1]</code></p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="使用2个栈实现一个队列"></a><a href="#使用2个栈实现一个队列" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用2个栈实现一个队列</h4>
<blockquote>
<p>思路</p>
</blockquote>
<pre><code class="hljs">栈A[]
栈B[]

入列<span class="hljs-number">1</span>
栈A[<span class="hljs-number">1</span>]
栈B[]

入列<span class="hljs-number">2</span>
栈A[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
栈B[]

入列<span class="hljs-number">3</span>
栈A[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
栈B[]

出列
拿到<span class="hljs-number">1</span>值
栈只能栈顶弹出

栈A[<span class="hljs-number">1</span>]
栈B[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>]
出栈<span class="hljs-number">1</span>即拿到
现在：
栈A[]
栈B[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>]
再倒入
栈A[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
栈B[]

入列<span class="hljs-number">4</span>
栈A[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
栈B[]

访问队列队首
栈A[<span class="hljs-number">2</span>]
栈B[<span class="hljs-number">4</span>，<span class="hljs-number">3</span>]
访问栈A的栈顶top()，返回
恢复
栈A[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
栈B[]
</code></pre>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SQueue</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">this</span>.s1 = <span class="hljs-keyword">new</span> Stack()
  <span class="hljs-keyword">this</span>.s2 = <span class="hljs-keyword">new</span> Stack()
  
  <span class="hljs-comment">// 入列</span>
  <span class="hljs-keyword">this</span>.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
    <span class="hljs-keyword">this</span>.s1.push(item)
  }
  
  <span class="hljs-comment">// 出列</span>
  <span class="hljs-keyword">this</span>.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.s1.size() &gt; <span class="hljs-number">1</span>) {
       <span class="hljs-keyword">this</span>.s2.push(<span class="hljs-keyword">this</span>.s1.pop())
    }
    <span class="hljs-keyword">const</span> deItem = <span class="hljs-keyword">this</span>.s1.pop()
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.s2.size()) {
       <span class="hljs-keyword">this</span>.s1.push(<span class="hljs-keyword">this</span>.s2.pop())  
    }
    <span class="hljs-keyword">return</span> deItem
  }
  
  <span class="hljs-comment">// 访问队首</span>
  <span class="hljs-keyword">this</span>.head = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.s1.size() &gt; <span class="hljs-number">1</span>) {
       <span class="hljs-keyword">this</span>.s2.push(<span class="hljs-keyword">this</span>.s1.pop())
    }
    <span class="hljs-keyword">const</span> headtem = <span class="hljs-keyword">this</span>.s1.top()
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.s2.size()) {
       <span class="hljs-keyword">this</span>.s1.push(<span class="hljs-keyword">this</span>.s2.pop())  
    }
    <span class="hljs-keyword">return</span> headtem
  }
}
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/09/05/queue">实现队列并应用</a></h1><p class="post-meta">September 5, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="队列"></a><a href="#队列" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>队列</h3>
<ul>
<li>先进后出</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.stores = []
}

Queue.prototype.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
  <span class="hljs-keyword">this</span>.stores.push(item)
}

Queue.prototype.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stores.shift()
}

Queue.prototype.head = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stores[<span class="hljs-number">0</span>]
}

Queue.prototype.size = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stores.length
}

Queue.prototype.tail = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stores[<span class="hljs-keyword">this</span>.stores.length - <span class="hljs-number">1</span>]
}

Queue.prototype.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>.stores.length
}

Queue.prototype.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.stores = []
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="应用"></a><a href="#应用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用</h3>
<ul>
<li>利用队列队首出，队尾进特性</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="约瑟夫环"></a><a href="#约瑟夫环" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>约瑟夫环</h4>
<p>一个数组[0-100], 每隔两个数删一个数，到末尾，再从头开始，直到最后一个，求其值</p>
<blockquote>
<p>思路</p>
</blockquote>
<pre><code class="hljs">队列： 出[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]进

出<span class="hljs-number">0</span>， <span class="hljs-number">0</span>不满足条件，继续后面排队
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>]   <span class="hljs-number">1</span>

出<span class="hljs-number">1</span>， <span class="hljs-number">1</span>不满足条件，继续后面排队
[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]   <span class="hljs-number">2</span>

出<span class="hljs-number">2</span>， <span class="hljs-number">2</span>满足条件，干掉
[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]   <span class="hljs-number">3</span>


出<span class="hljs-number">3</span>，<span class="hljs-number">3</span>不满足条件，继续后面排队
[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]   <span class="hljs-number">4</span>

出<span class="hljs-number">4</span>，<span class="hljs-number">4</span>不满足条件，继续后面排队
[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]  <span class="hljs-number">5</span>


出<span class="hljs-number">5</span>，<span class="hljs-number">5</span>满足条件，干掉
[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]   <span class="hljs-number">6</span>

出<span class="hljs-number">6</span>，<span class="hljs-number">6</span>不满足条件，继续后面排队
[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>, <span class="hljs-number">6</span>]  <span class="hljs-number">7</span>

出<span class="hljs-number">7</span>，<span class="hljs-number">7</span>不满足条件，继续后面排队
[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]  <span class="hljs-number">8</span>

出<span class="hljs-number">8</span>，<span class="hljs-number">8</span>满足条件，干掉
[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]  <span class="hljs-number">9</span>

...

最后队列中size为<span class="hljs-number">1</span>时， 停止循环，访问队列的head即可
</code></pre>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleRing</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> Queue()
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    queue.enqueue(arr[i])
  }
  <span class="hljs-keyword">let</span> stepIdx = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (queue.size() != <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">let</span> item = queue.dequeue()
    stepIdx += <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> (stepIdx % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) {
      queue.enqueue(item)
    }
  }
  <span class="hljs-keyword">return</span> queue.head()
}
</code></pre>
<blockquote>
<p>执行过程</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/stupidWall/liuxiaobai/master/img/blog/2019/1567655806583.png" /></p>
<h4><a class="anchor" aria-hidden="true" id="斐波切那数列"></a><a href="#斐波切那数列" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>斐波切那数列</h4>
<p><code>[1,1,2,3,5]</code></p>
<p>输入n，返回对应值</p>
<blockquote>
<p>思路</p>
</blockquote>
<pre><code class="hljs">队列 [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]

当n = <span class="hljs-number">1</span> 或 <span class="hljs-number">2</span>
出列： [<span class="hljs-number">1</span>]
返回队首: <span class="hljs-number">1</span>


当n = <span class="hljs-number">3</span>
出列<span class="hljs-number">1</span>
队首<span class="hljs-number">1</span>
<span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>
入列<span class="hljs-number">2</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
最后出列<span class="hljs-number">1</span>， 返回队首<span class="hljs-number">2</span>

当n = <span class="hljs-number">5</span>

队列演变:
[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
[<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]

最后出列<span class="hljs-number">3</span>， 返回队首<span class="hljs-number">5</span>
</code></pre>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonaci</span>(<span class="hljs-params">num</span>) </span>{
  <span class="hljs-keyword">const</span> myQ = <span class="hljs-keyword">new</span> Queue()
  myQ.enqueue(<span class="hljs-number">1</span>)
  myQ.enqueue(<span class="hljs-number">1</span>)
  <span class="hljs-keyword">let</span> stepIdx = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (stepIdx &lt; num - <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">let</span> deO = myQ.dequeue()
    <span class="hljs-keyword">let</span> headO = myQ.head()
    myQ.enqueue(deO + headO)
    stepIdx += <span class="hljs-number">1</span>
  }
  myQ.dequeue()
  <span class="hljs-keyword">return</span> myQ.head()
}
</code></pre>
<pre><code class="hljs css language-javascript">fibonaci(<span class="hljs-number">8</span>)
<span class="hljs-comment">// 21</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="使用队列实现栈"></a><a href="#使用队列实现栈" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用队列实现栈</h4>
<ul>
<li><p>入栈</p></li>
<li><p>出栈</p></li>
<li><p>访问栈顶</p></li>
</ul>
<p>实现上面的三个方法</p>
<blockquote>
<p>思路</p>
</blockquote>
<ul>
<li><p>创建2个队列： A队列、B队列</p></li>
<li><p>入栈<code>1</code>、<code>2</code>、<code>3</code></p>
<pre><code class="hljs">入栈 <span class="hljs-number">1</span>
队列A [<span class="hljs-number">1</span>]
队列B []


入栈 <span class="hljs-number">2</span>
队列A [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
队列B []


入栈 <span class="hljs-number">3</span>
队列A [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
队列B []
</code></pre></li>
<li><p>出栈</p>
<pre><code class="hljs">想办法从队列A中取<span class="hljs-number">3</span>

倒入队列B
队列A [<span class="hljs-number">3</span>]
队列B [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]

队列A剩下最后一个，使用出列获取<span class="hljs-number">3</span>
最后是出栈成功
队列A []
队列B [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
</code></pre></li>
<li><p>再入栈4</p>
<pre><code class="hljs">队列A []
队列B [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]
</code></pre></li>
<li><p>访问栈顶值</p>
<pre><code class="hljs">队列A [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]
队列B []
调队列A的tail方法
</code></pre>
<blockquote>
<p>代码</p>
</blockquote></li>
</ul>
<pre><code class="hljs css language-javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">QStack</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.q1 = <span class="hljs-keyword">new</span> Queue()
    <span class="hljs-keyword">this</span>.q2 = <span class="hljs-keyword">new</span> Queue()
    <span class="hljs-keyword">this</span>.findQ = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.q2.isEmpty() &amp;&amp; <span class="hljs-keyword">this</span>.q1.isEmpty()) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.q2
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.q1
    }
  }

  <span class="hljs-comment">// 入栈</span>
  QStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'sssss'</span>, <span class="hljs-keyword">this</span>.findQ())
    <span class="hljs-keyword">this</span>.findQ().enqueue(item)
  }

  <span class="hljs-comment">// 出栈</span>
  QStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.findQ().size() &gt; <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.q2.enqueue(
        <span class="hljs-keyword">this</span>.findQ().dequeue()
      )     
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.findQ().dequeue()
  }

  <span class="hljs-comment">// 栈顶</span>
  QStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.findQ().tail()
  }


  <span class="hljs-keyword">const</span> qs = <span class="hljs-keyword">new</span> QStack()

  qs.push(<span class="hljs-string">'A'</span>)
  qs.push(<span class="hljs-string">'B'</span>)
  qs.push(<span class="hljs-string">'C1'</span>)

  <span class="hljs-built_in">console</span>.log(
    <span class="hljs-string">'xxxxx'</span>,
    qs.pop()
  )
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/08/27/jsonp">实现一个JSONP</a></h1><p class="post-meta">August 27, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="代码如下"></a><a href="#代码如下" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码如下</h3>
<pre><code class="hljs css language-javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">window,document</span>) </span>{
<span class="hljs-meta">    "use strict"</span>;
    <span class="hljs-keyword">var</span> jsonp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url,data,callback</span>) </span>{

        <span class="hljs-comment">// 1.将传入的data数据转化为url字符串形式</span>
        <span class="hljs-comment">// {id:1,name:'jack'} =&gt; id=1&amp;name=jack</span>
        <span class="hljs-keyword">var</span> dataString = url.indexof(<span class="hljs-string">'?'</span>) == <span class="hljs-number">-1</span>? <span class="hljs-string">'?'</span>: <span class="hljs-string">'&amp;'</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> data){
            dataString += key + <span class="hljs-string">'='</span> + data[key] + <span class="hljs-string">'&amp;'</span>;
        };

        <span class="hljs-comment">// 2 处理url中的回调函数</span>
        <span class="hljs-comment">// cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span>
        <span class="hljs-keyword">var</span> cbFuncName = <span class="hljs-string">'my_json_cb_'</span> + <span class="hljs-built_in">Math</span>.random().toString().replace(<span class="hljs-string">'.'</span>,<span class="hljs-string">''</span>);
        dataString += <span class="hljs-string">'callback='</span> + cbFuncName;

        <span class="hljs-comment">// 3.创建一个script标签并插入到页面中</span>
        <span class="hljs-keyword">var</span> scriptEle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
        scriptEle.src = url + dataString;

        <span class="hljs-comment">// 4.挂载回调函数</span>
        <span class="hljs-built_in">window</span>[cbFuncName] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
            callback(data);
            <span class="hljs-comment">// 处理完回调函数的数据之后，删除jsonp的script标签</span>
            <span class="hljs-built_in">document</span>.body.removeChild(scriptEle);
        }

        <span class="hljs-built_in">document</span>.body.appendChild(scriptEle);
    }

    <span class="hljs-built_in">window</span>.$jsonp = jsonp;

})(<span class="hljs-built_in">window</span>,<span class="hljs-built_in">document</span>)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="步骤"></a><a href="#步骤" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>步骤</h3>
<ul>
<li><p>使用时，传入参数<code>key</code>:<code>value</code>对象形式，则需要把它转化为<code>url</code>参数形式，拼接起来， 即<code>{id:1,name:'jack'} =&gt; id=1&amp;name=jack</code></p></li>
<li><p>回调函数的处理</p></li>
<li><p>创建一个script标签并插入到页面中<code>createElement</code>、<code>appendChild</code></p></li>
<li><p>挂载回调函数， 回调函数里，处理完业务逻辑后，移除<code>script</code>标签</p></li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/08/26/柯里化">柯里化</a></h1><p class="post-meta">August 26, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="概念"></a><a href="#概念" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>概念</h3>
<p>柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术， 其实是用闭包把参数保存起来，当参数的数量足够执行函数了，就开始执行函数</p>
<h3><a class="anchor" aria-hidden="true" id="实现"></a><a href="#实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现</h3>
<pre><code class="hljs css language-javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">currying</span>(<span class="hljs-params">fn, ...args</span>) </span>{
    <span class="hljs-keyword">if</span> (args.length &gt;= fn.length) {
      <span class="hljs-keyword">return</span> fn(...args);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args2</span>) =&gt;</span> currying(fn, ...args, ...args2);
    }
  }
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/08/26/实现一个Promise">实现一个Promise</a></h1><p class="post-meta">August 26, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><p><a href="http://www.conardli.top/docs/JavaScript/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0promise.html#%E5%9F%BA%E7%A1%80%E7%89%88%E6%9C%AC">文章来源</a></p>
<h3><a class="anchor" aria-hidden="true" id="promise-怎么用的"></a><a href="#promise-怎么用的" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>promise</code>怎么用的？</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    resolve(<span class="hljs-string">'hello'</span>)
})
p.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(v) 
    <span class="hljs-comment">// 'hello'</span>
})
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="分析"></a><a href="#分析" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分析</h3>
<ul>
<li><p><code>Promise</code>接受一个函数， 该函数有2参数，分别是<code>resolve</code>、<code>reject</code></p></li>
<li><p><code>resolve</code> 将<code>PENDING</code>改变为<code>FULFILLED</code></p></li>
<li><p><code>reject</code> 将<code>PENDING</code>改变为<code>REJECTED</code></p></li>
<li><p>变为<code>FULFILLED</code>状态后具有一个唯一的<code>value</code></p></li>
<li><p>变为<code>REJECTED</code>状态后具有一个唯一的<code>reason</code></p></li>
<li><p><code>Promise</code>只能从<code>PENDING</code>改变为<code>FULFILLED</code>、<code>REJECTED</code>， 只能改变一次</p></li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">'pending'</span>;
<span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">'fulfilled'</span>;
<span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">'rejected'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>{
    <span class="hljs-keyword">this</span>.state = PENDING;
    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.reason = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === PENDING) {
        <span class="hljs-keyword">this</span>.state = FULFILLED;
        <span class="hljs-keyword">this</span>.value = value;
    }
    }

    <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === PENDING) {
        <span class="hljs-keyword">this</span>.state = REJECTED;
        <span class="hljs-keyword">this</span>.reason = reason;
    }
    }

    <span class="hljs-keyword">try</span> {
    executor(resolve, reject);
    } <span class="hljs-keyword">catch</span> (reason) {
    reject(reason);
    }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="then-方法"></a><a href="#then-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>then</code>方法</h3>
<ul>
<li><p><code>then</code>方法接受两个参数<code>onFulfilled</code>、<code>onRejected</code>，它们分别在状态由<code>PENDING</code>改变为<code>FULFILLED</code>、<code>REJECTED</code>后调用</p></li>
<li><p>一个<code>promise</code>可绑定多个then方法</p></li>
<li><p><code>then</code>方法可以同步调用也可以异步调用, 同步调用：状态已经改变，直接调用<code>onFulfilled</code>方法, 异步调用：状态还是<code>PENDING</code>，将<code>onFulfilled</code>、<code>onRejected</code>分别加入两个函数数组<code>onFulfilledCallbacks</code>、<code>onRejectedCallbacks</code>，当异步调用<code>resolve</code>和<code>reject</code>时，将两个数组中绑定的事件循环执行。</p></li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>{
    <span class="hljs-keyword">this</span>.state = PENDING;
    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.reason = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.onFulfilledCallbacks = [];
    <span class="hljs-keyword">this</span>.onRejectedCallbacks = [];

    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === PENDING) {
        <span class="hljs-keyword">this</span>.state = FULFILLED;
        <span class="hljs-keyword">this</span>.value = value;
        <span class="hljs-keyword">this</span>.onFulfilledCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fun</span> =&gt;</span> {
        fun();
        });
    }
    }

    <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === PENDING) {
        <span class="hljs-keyword">this</span>.state = REJECTED;
        <span class="hljs-keyword">this</span>.reason = reason;
        <span class="hljs-keyword">this</span>.onRejectedCallbacks.forEach(<span class="hljs-function"><span class="hljs-params">fun</span> =&gt;</span> {
        fun();
        });
    }
    }

    <span class="hljs-keyword">try</span> {
    executor(resolve, reject);
    } <span class="hljs-keyword">catch</span> (reason) {
    reject(reason);
    }
}

MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>{
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) {
    <span class="hljs-keyword">case</span> FULFILLED:
        onFulfilled(<span class="hljs-keyword">this</span>.value);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> REJECTED:
        onFulfilled(<span class="hljs-keyword">this</span>.value);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> PENDING:
        <span class="hljs-keyword">this</span>.onFulfilledCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        onFulfilled(<span class="hljs-keyword">this</span>.value);
        })
        <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        onRejected(<span class="hljs-keyword">this</span>.reason);
        })
        <span class="hljs-keyword">break</span>;
    }
}
</code></pre>
<ul>
<li>虽然resolve是同步执行的，我们必须保证then是异步调用的，我们用settimeout来模拟异步调用</li>
</ul>
<pre><code class="hljs css language-javascript"> MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onFulfilled != <span class="hljs-string">'function'</span>) {
    onFulfilled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> value;
    }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected != <span class="hljs-string">'function'</span>) {
    onRejected = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>{
        <span class="hljs-keyword">throw</span> reason;
    }
    }
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) {
    <span class="hljs-keyword">case</span> FULFILLED:
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        onFulfilled(<span class="hljs-keyword">this</span>.value);
        }, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> REJECTED:
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        onRejected(<span class="hljs-keyword">this</span>.reason);
        }, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> PENDING:
        <span class="hljs-keyword">this</span>.onFulfilledCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            onFulfilled(<span class="hljs-keyword">this</span>.value);
        }, <span class="hljs-number">0</span>);
        })
        <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            onRejected(<span class="hljs-keyword">this</span>.reason);
        }, <span class="hljs-number">0</span>);
        })
        <span class="hljs-keyword">break</span>;
    }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="then-方法链式调用"></a><a href="#then-方法链式调用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>then</code>方法链式调用</h3>
<p>保证链式调用，即<code>then</code>方法中要返回一个新的<code>promise</code>，并将<code>then</code>方法的返回值进行<code>resolve</code></p>
<pre><code class="hljs css language-javascript">MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onFulfilled != <span class="hljs-string">'function'</span>) {
    onFulfilled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> value;
    }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRejected != <span class="hljs-string">'function'</span>) {
    onRejected = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>{
        <span class="hljs-keyword">throw</span> reason;
    }
    }
    <span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) {
        <span class="hljs-keyword">case</span> FULFILLED:
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value);
            resolve(x);
            } <span class="hljs-keyword">catch</span> (reason) {
            reject(reason);
            }
        }, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> REJECTED:
        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">const</span> x = onRejected(<span class="hljs-keyword">this</span>.reason);
            resolve(x);
            } <span class="hljs-keyword">catch</span> (reason) {
            reject(reason);
            }
        }, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> PENDING:
        <span class="hljs-keyword">this</span>.onFulfilledCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">const</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value);
                resolve(x);
            } <span class="hljs-keyword">catch</span> (reason) {
                reject(reason);
            }
            }, <span class="hljs-number">0</span>);
        })
        <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">const</span> x = onRejected(<span class="hljs-keyword">this</span>.reason);
                resolve(x);
            } <span class="hljs-keyword">catch</span> (reason) {
                reject(reason);
            }
            }, <span class="hljs-number">0</span>);
        })
        <span class="hljs-keyword">break</span>;
    }
    })
    <span class="hljs-keyword">return</span> promise2;
}

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="catch-方法"></a><a href="#catch-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>catch</code>方法</h3>
<p>若上面没有定义<code>reject</code>方法，所有的异常会走向<code>catch</code>方法</p>
<pre><code class="hljs css language-javascript">MyPromise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onRejected</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, onRejected);
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="finally-方法"></a><a href="#finally-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>finally</code>方法</h3>
<p>不管是resolve还是reject都会调用finally</p>
<pre><code class="hljs css language-javascript">MyPromise.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
       fn();
       <span class="hljs-keyword">return</span> value;
    }, reason =&gt; {
        fn();
        <span class="hljs-keyword">throw</span> reason;
    });
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="promiseresolve"></a><a href="#promiseresolve" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>Promise.resolve</code></h3>
<p><code>Promise.resolve</code>用来生成一个直接处于<code>FULFILLED</code>状态的<code>Promise</code></p>
<pre><code class="hljs css language-javascript">MyPromise.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    resolve(value);
  });
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="promisereject"></a><a href="#promisereject" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>Promise.reject</code></h3>
<p><code>Promise.reject</code>用来生成一个直接处于<code>REJECTED</code>状态的<code>Promise</code></p>
<pre><code class="hljs css language-javascript">MyPromise.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    reject(reason);
  });
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="all-方法"></a><a href="#all-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>all</code>方法</h3>
<p>接受一个<code>promise</code>数组，当所有<code>promise</code>状态<code>resolve</code>后，执行<code>resolve</code></p>
<pre><code class="hljs css language-javascript">MyPromise.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (promises.length === <span class="hljs-number">0</span>) {
        resolve([]);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> result = [];
        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.length; i++) {
        promises[i].then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            result[i] = data;
            <span class="hljs-keyword">if</span> (++index === promises.length) {
            resolve(result);
            }
        }, err =&gt; {
            reject(err);
            <span class="hljs-keyword">return</span>;
        });
        }
    }
    });
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="race-方法"></a><a href="#race-方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>race</code>方法</h3>
<p>接受一个<code>promise</code>数组，当有一个<code>promise</code>状态<code>resolve</code>后，执行<code>resolve</code></p>
<pre><code class="hljs css language-javascript">MyPromise.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (promises.length === <span class="hljs-number">0</span>) {
        resolve();
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.length; i++) {
        promises[i].then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            resolve(data);
        }, err =&gt; {
            reject(err);
            <span class="hljs-keyword">return</span>;
        });
        }
    }
    });
}
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/08/26/实现instanceof">实现一个instanceof</a></h1><p class="post-meta">August 26, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="原理"></a><a href="#原理" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>原理</h3>
<pre><code class="hljs css language-javascript">a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>
</code></pre>
<p>判断Object的prototype是否在a的原型链上</p>
<h3><a class="anchor" aria-hidden="true" id="实现"></a><a href="#实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">target, origin</span>) </span>{
    <span class="hljs-keyword">const</span> proto = target.__proto__
    <span class="hljs-keyword">if</span> (proto) {
        <span class="hljs-keyword">if</span> (proto === origin.prototype) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> myInstanceof(proto, origin)
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
}
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/08/14/Object.assign">模拟实现Object.assign</a></h1><p class="post-meta">August 14, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">柳小白</a></p></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="objectassign"></a><a href="#objectassign" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object.assign</h2>
<h3><a class="anchor" aria-hidden="true" id="用法"></a><a href="#用法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>用法</h3>
<p>用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> target = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> source = { <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">5</span> };

<span class="hljs-keyword">const</span> returnedTarget = <span class="hljs-built_in">Object</span>.assign(target, source);

<span class="hljs-built_in">console</span>.log(target);
<span class="hljs-comment">// expected output: Object { a: 1, b: 4, c: 5 }</span>

<span class="hljs-built_in">console</span>.log(returnedTarget);
<span class="hljs-comment">// expected output: Object { a: 1, b: 4, c: 5 }</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="实现"></a><a href="#实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.assign !== <span class="hljs-string">'function'</span>) {
  <span class="hljs-built_in">Object</span>.assign = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>{
    <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Connot convert undefined or null to object'</span>)
    }
    <span class="hljs-keyword">const</span> to = <span class="hljs-built_in">Object</span>(target)
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>; index &lt; <span class="hljs-built_in">arguments</span>.length; index++) {
      <span class="hljs-keyword">const</span> nextSource = <span class="hljs-built_in">arguments</span>[index]
      <span class="hljs-keyword">if</span> (nextSource != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> nextKey <span class="hljs-keyword">in</span> nextSource) {
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey]
          }
        }
      }
    }
    <span class="hljs-keyword">return</span> to
  }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next" href="/liuxiaobai/blog/page2/">Next →</a></div></div></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'my-api-key',
                indexName: 'my-index-name',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>