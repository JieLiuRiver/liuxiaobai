<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blog · 柳小白</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Be Water, My Friend!"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blog · 柳小白"/><meta property="og:type" content="website"/><meta property="og:url" content="https://github.com/stupidWall/liuxiaobai/liuxiaobai/"/><meta property="og:description" content="Be Water, My Friend!"/><meta property="og:image" content="https://github.com/stupidWall/liuxiaobai/liuxiaobai/img/1.jpeg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://github.com/stupidWall/liuxiaobai/liuxiaobai/img/1.jpeg"/><link rel="shortcut icon" href="/liuxiaobai/"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night.min.css"/><link rel="alternate" type="application/atom+xml" href="https://github.com/stupidWall/liuxiaobai/liuxiaobai/blog/atom.xml" title="柳小白 Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://github.com/stupidWall/liuxiaobai/liuxiaobai/blog/feed.xml" title="柳小白 Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/liuxiaobai/js/scrollSpy.js"></script><link rel="stylesheet" href="/liuxiaobai/css/main.css"/><script src="/liuxiaobai/js/codetabs.js"></script></head><body class="blog"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/liuxiaobai/"><h2 class="headerTitle">柳小白</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/liuxiaobai/blog/" target="_self">Blog</a></li><li class=""><a href="https://github.com/stupidWall/liuxiaobai" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>All Blog Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">All Blog Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2020/08/21/vue">iview</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2020/08/15/对象转内联样式">对象转内联样式</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/10/23/SSR">服务端渲染SSR</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/10/11/vue双向绑定">vue双向绑定原理</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/10/08/vuex">实现一个简单的vuex</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/09/30/vue-router">实现一个简单的vue-router</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/09/16/tree2">二叉树</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/09/08/linklist">实现链表并应用</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/09/05/stack">实现栈并应用</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/09/05/queue">实现队列并应用</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/27/jsonp">实现一个JSONP</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/10/13.vue源码">vue源码</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/26/柯里化">柯里化</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/26/实现一个Promise">实现一个Promise</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/26/实现instanceof">实现一个instanceof</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/08/14/Object.assign">模拟实现Object.assign</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/14/TypeScript">TypeScript</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/12/utils">收集开源项目好用工具函数</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/12/TaroUi">taro-ui</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/11/events">读Taro消息机制源码笔记</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/10/面试题">火爆了的前端面试题</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/泛型">泛型（TypeScript学习笔记）</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/格式化日期">格式化日期</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/枚举">枚举（TypeScript学习笔记）</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/react生命周期">React生命周期</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/06/parseStyle">内联样式转对象</a></li><li class="navListItem"><a class="navItem" href="/liuxiaobai/blog/2019/07/05/驼峰">中横线转驼峰变量</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2020/08/21/vue">iview</a></h1><p class="post-meta">August 21, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="动态组件"></a><a href="#动态组件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>动态组件</h3>
<pre><code class="hljs css language-javascript">&lt;component :is=<span class="hljs-string">"wrapperComponent"</span>&gt;
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span>

...

computed: {
  wrapperComponent() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.affix ? <span class="hljs-string">'Affix'</span> : <span class="hljs-string">'div'</span>;
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="匹配锚点"></a><a href="#匹配锚点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>匹配锚点</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> reg =  <span class="hljs-regexp">/#([^#]+)$/</span>
<span class="hljs-keyword">var</span> match = reg.exec(<span class="hljs-string">'https://www.iviewui.com/components/anchor#AnchorLink_props'</span>)

<span class="hljs-comment">// match</span>
[
  <span class="hljs-string">'#AnchorLink_props'</span>,
  <span class="hljs-string">'AnchorLink_props'</span>,
  ...
]
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="节点元素滚动动画"></a><a href="#节点元素滚动动画" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>节点元素滚动动画</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scrollTop</span>(<span class="hljs-params">el, from = <span class="hljs-number">0</span>, to, duration = <span class="hljs-number">500</span>, endCallback</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.requestAnimationFrame) {
        <span class="hljs-built_in">window</span>.requestAnimationFrame = (
            <span class="hljs-built_in">window</span>.webkitRequestAnimationFrame ||
            <span class="hljs-built_in">window</span>.mozRequestAnimationFrame ||
            <span class="hljs-built_in">window</span>.msRequestAnimationFrame ||
            <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.setTimeout(callback, <span class="hljs-number">1000</span>/<span class="hljs-number">60</span>);
            }
        );
    }
    <span class="hljs-keyword">const</span> difference = <span class="hljs-built_in">Math</span>.abs(<span class="hljs-keyword">from</span> - to);
    <span class="hljs-keyword">const</span> step = <span class="hljs-built_in">Math</span>.ceil(difference / duration * <span class="hljs-number">50</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scroll</span>(<span class="hljs-params">start, end, step</span>) </span>{
        <span class="hljs-keyword">if</span> (start === end) {
            endCallback &amp;&amp; endCallback();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">let</span> d = (start + step &gt; end) ? end : start + step;
        <span class="hljs-keyword">if</span> (start &gt; end) {
            d = (start - step &lt; end) ? end : start - step;
        }

        <span class="hljs-keyword">if</span> (el === <span class="hljs-built_in">window</span>) {
            <span class="hljs-built_in">window</span>.scrollTo(d, d);
        } <span class="hljs-keyword">else</span> {
            el.scrollTop = d;
        }
        <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> scroll(d, end, step));
    }
    scroll(<span class="hljs-keyword">from</span>, to, step);
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="组件通信"></a><a href="#组件通信" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>组件通信</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">broadcast</span>(<span class="hljs-params">componentName, eventName, params</span>) </span>{
    <span class="hljs-keyword">this</span>.$children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> name = child.$options.name;

        <span class="hljs-keyword">if</span> (name === componentName) {
            child.$emit.apply(child, [eventName].concat(params));
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// todo 如果 params 是空数组，接收到的会是 undefined</span>
            broadcast.apply(child, [componentName, eventName].concat([params]));
        }
    });
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">methods</span>: {
        dispatch(componentName, eventName, params) {
            <span class="hljs-keyword">let</span> parent = <span class="hljs-keyword">this</span>.$parent || <span class="hljs-keyword">this</span>.$root;
            <span class="hljs-keyword">let</span> name = parent.$options.name;

            <span class="hljs-keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) {
                parent = parent.$parent;

                <span class="hljs-keyword">if</span> (parent) {
                    name = parent.$options.name;
                }
            }
            <span class="hljs-keyword">if</span> (parent) {
                parent.$emit.apply(parent, [eventName].concat(params));
            }
        },
        broadcast(componentName, eventName, params) {
            broadcast.call(<span class="hljs-keyword">this</span>, componentName, eventName, params);
        }
    }
};
</code></pre>
<p>使用</p>
<pre><code class="hljs css language-javascript">mixins: [ Emitter ]
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="父组件-子组件通信"></a><a href="#父组件-子组件通信" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>父组件 =&gt; 子组件通信</h3>
<ul>
<li><p>属性<code>$props</code></p></li>
<li><p>特性 <code>$attrs</code></p></li>
</ul>
<pre><code class="hljs"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">"hello"</span>/&gt;</span>


Child中未在props中声明msg, 即可这样访问：

<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">{{$attrs.msg}}</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</span></code></pre>
<h3><a class="anchor" aria-hidden="true" id="refs-通信"></a><a href="#refs-通信" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>$refs 通信</h3>
<pre><code class="hljs"><span class="hljs-keyword">this</span>.$<span class="hljs-built_in">ref</span>s.xx

<span class="hljs-keyword">this</span>.$children[<span class="hljs-number">0</span>]
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="子组件-父组件通信"></a><a href="#子组件-父组件通信" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>子组件 =&gt; 父组件通信</h3>
<p>事件</p>
<pre><code class="hljs">&lt;<span class="hljs-selector-tag">p</span> @click=<span class="hljs-string">"do"</span>&gt;&lt;/p&gt;

<span class="hljs-function"><span class="hljs-title">do</span><span class="hljs-params">()</span></span> {
    this.<span class="hljs-variable">$emit</span>(<span class="hljs-string">'on-do'</span>, null)
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="兄弟节点-通信"></a><a href="#兄弟节点-通信" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>兄弟节点 通信</h3>
<p>共同祖辈搭桥组件通信, <code>$parent</code>或<code>$root</code></p>
<pre><code class="hljs"><span class="hljs-comment">// border1</span>
<span class="hljs-keyword">this</span>.$<span class="hljs-built_in">parent</span>.$<span class="hljs-keyword">on</span>(<span class="hljs-string">'on-do'</span>, <span class="hljs-literal">null</span>)


<span class="hljs-comment">// border2</span>
<span class="hljs-keyword">this</span>.$<span class="hljs-built_in">parent</span>.$emit(<span class="hljs-string">'on-do'</span>)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="祖先组件与后代之间通信"></a><a href="#祖先组件与后代之间通信" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>祖先组件与后代之间通信</h3>
<h4><a class="anchor" aria-hidden="true" id="provide-依赖注入"></a><a href="#provide-依赖注入" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>provide 依赖注入</h4>
<p>由于使用 <code>$parent</code> 属性无法很好的扩展到更深层级的嵌套组件上</p>
<p>vue提供了新的实例选项：provide 和 inject</p>
<p>父组件</p>
<pre><code class="hljs css language-javascript">provide () {
  <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">anchorCom</span>: <span class="hljs-keyword">this</span>
  };
}
</code></pre>
<p>子组件</p>
<pre><code class="hljs css language-javascript">inject: ['anchorCom']

# 使用
this.anchorCom.xxx
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="传入v-model到组件内部"></a><a href="#传入v-model到组件内部" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>传入v-model到组件内部</h3>
<pre><code class="hljs css language-javascript">props: {
    <span class="hljs-attr">value</span>: {
        <span class="hljs-attr">type</span>: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Number</span>],
        <span class="hljs-attr">default</span>: <span class="hljs-string">''</span>
    }
},
data () {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">currentVal</span>: <span class="hljs-keyword">this</span>.value
    }
},
<span class="hljs-attr">watch</span>: {
    value (val) {
        <span class="hljs-keyword">this</span>.currentVal = val
    }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="任意2个组件之间通信"></a><a href="#任意2个组件之间通信" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>任意2个组件之间通信</h3>
<h4><a class="anchor" aria-hidden="true" id="事件总线-创建一个bus类-负责事件派发-监听和回调"></a><a href="#事件总线-创建一个bus类-负责事件派发-监听和回调" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>事件总线，创建一个bus类，负责事件派发、监听和回调</h4>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bus</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-comment">// {</span>
    <span class="hljs-comment">//   eventName1:[fn1,fn2],</span>
    <span class="hljs-comment">//   eventName2:[fn3,fn4],</span>
    <span class="hljs-comment">// }</span>
    <span class="hljs-keyword">this</span>.callbacks = {};
  }
  $on(name, fn) {
    <span class="hljs-keyword">this</span>.callbacks[name] = <span class="hljs-keyword">this</span>.callbacks[name] || [];
    <span class="hljs-keyword">this</span>.callbacks[name].push(fn);
  }
  $emit(name, args) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.callbacks[name]) {
      <span class="hljs-comment">// 存在 遍历所有callback</span>
      <span class="hljs-keyword">this</span>.callbacks[name].forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(args));
    }
  }
}


Vue.prototype.$bus = <span class="hljs-keyword">new</span> Bus()


<span class="hljs-keyword">this</span>.$bus.$on(<span class="hljs-string">'on-do'</span>, v =&gt; {

})

<span class="hljs-keyword">this</span>.$bus.$emit(<span class="hljs-string">'on-do'</span>, <span class="hljs-literal">null</span>)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="获取元素布局信息"></a><a href="#获取元素布局信息" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>获取元素布局信息</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">this</span>.$el.getBoundingClientRect()
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="回到顶部组件"></a><a href="#回到顶部组件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>回到顶部组件</h3>
<p>当滚动高度大于等于100时， 显示回到顶部按钮</p>
<p><img src="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/pageYOffset" alt="pageYOffset"></p>
<pre><code class="hljs css language-javascript"><span class="hljs-built_in">window</span>.pageYOffset &gt;= <span class="hljs-number">100</span>
</code></pre>
<p>获取<code>window</code>滚动的高度</p>
<pre><code class="hljs css language-javascript"><span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="注入弹窗组件到-body"></a><a href="#注入弹窗组件到-body" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注入弹窗组件到<code>body</code></h3>
<p>使用</p>
<p><code>Notice</code>是提示组件</p>
<p><code>create</code>方法返回组件实例</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> comp = create(Notice, {
    <span class="hljs-attr">title</span>: <span class="hljs-string">"社会你杨哥喊你来搬砖"</span>,
    <span class="hljs-attr">message</span>: isValidate ? <span class="hljs-string">"请求登录!"</span> : <span class="hljs-string">"校验失败!"</span>,
    <span class="hljs-attr">duration</span>: <span class="hljs-number">3000</span>
})

comp.show()
</code></pre>
<blockquote>
<p>create.js</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params">Component, props</span>) </span>{
    <span class="hljs-comment">// 1. 创建Component实例</span>
    <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> Vue({
        render(h) {
            <span class="hljs-comment">// 渲染函数使用</span>
            <span class="hljs-comment">// h === createElement</span>
            <span class="hljs-comment">// h(Component) =&gt; vdom</span>
            <span class="hljs-keyword">return</span> h(Component, {props})
        }
    }).$mount() <span class="hljs-comment">// 先渲染不挂载</span>

    <span class="hljs-comment">// 方式2：Vue.extend() 返回组件构造函数</span>
    <span class="hljs-comment">// const Ctor = Vue.extend(Component)</span>
    <span class="hljs-comment">// const comp = new Ctor({propsData: props})    </span>
    <span class="hljs-comment">// document.body.appendChild(comp.$el)</span>

    <span class="hljs-comment">// 获取dom</span>
    <span class="hljs-built_in">document</span>.body.appendChild(vm.$el)

    <span class="hljs-comment">// 2. 挂载</span>
    <span class="hljs-keyword">const</span> comp = vm.$children[<span class="hljs-number">0</span>];

    <span class="hljs-comment">// 3. 销毁</span>
    comp.remove = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">document</span>.body.removeChild(vm.$el)
        vm.$destroy()
    }

    <span class="hljs-keyword">return</span> comp
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="插槽"></a><a href="#插槽" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>插槽</h3>
<h4><a class="anchor" aria-hidden="true" id="具名-匿名"></a><a href="#具名-匿名" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>具名 &amp; 匿名</h4>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">// my-com</span>
&lt;div&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>


<span class="hljs-comment">// 使用</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-com</span>&gt;</span>
    // 默认
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    // title槽位
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">my-com</span>&gt;</span></span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="作用域"></a><a href="#作用域" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>作用域</h4>
<pre><code class="hljs css language-javascript"><span class="hljs-comment">// my-com</span>
&lt;div&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">prop1</span>=<span class="hljs-string">"hello world"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>


<span class="hljs-comment">// 使用</span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-com</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"{prop1}"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{prop1}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">my-com</span>&gt;</span></span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="sync-v-model-区别"></a><a href="#sync-v-model-区别" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.sync</code>&amp;<code>v-model</code>区别</h3>
<p><code>v-model</code>是语法糖, 多用于表单元素</p>
<pre><code class="hljs css language-javascript">&lt;input v-model=<span class="hljs-string">"username"</span> /&gt;
&lt;!-- 相当于 --&gt;
&lt;input :value="username" @input="usernme=$event" /&gt;
</code></pre>
<p>父组件传的参数，子组件想修改， 使用<code>.sync</code></p>
<pre><code class="hljs css language-javascript">&lt;HelloWorld :value.sync=<span class="hljs-string">"test"</span>/&gt;

test: <span class="hljs-string">'祝大家'</span>
</code></pre>
<p><code>HelloWorld</code></p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">"update:value"</span>, <span class="hljs-string">"国庆快乐"</span>);
</code></pre>
<p>import store from &quot;./store&quot;;</p>
<h3><a class="anchor" aria-hidden="true" id="路由权限-vuex"></a><a href="#路由权限-vuex" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>路由权限 &amp; Vuex</h3>
<p><code>main.js</code></p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">"./App.vue"</span>;

<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">"./router"</span>;
<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">"./store"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./permission'</span>


<span class="hljs-keyword">new</span> Vue({
  router,
  store,
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),
}).$mount(<span class="hljs-string">"#app"</span>);

</code></pre>
<p><code>permission.js</code></p>
<ul>
<li>如果没登录， 且访问的是白名单路由，过； 其他没登录的，跳转到登录页</li>
<li>如果已登录， 访问的是登陆页 =&gt; 回到首页；</li>
<li>如果已登录，从<code>store</code>里看该用户<code>roles</code>有么有，有 =&gt; 过；  没有， 去获取<code>dispatch(&quot;user/getInfo&quot;)</code>,  获取到后去对比判断校验<code>permission/generateRoutes</code>,  校验成功的追加<code>addRoutes</code>,  最后路由再进来一次<code>next({ ...to })</code></li>
<li></li>
</ul>
<pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">"./router"</span>;
<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">"./store"</span>;

<span class="hljs-keyword">const</span> whiteList = [<span class="hljs-string">"/login"</span>]; <span class="hljs-comment">// 无需令牌白名单</span>
 
<span class="hljs-comment">// 全局守卫</span>
router.beforeEach(<span class="hljs-keyword">async</span> (to, <span class="hljs-keyword">from</span>, next) =&gt; {
  <span class="hljs-comment">// 获取令牌判断用户是否登录</span>
  <span class="hljs-keyword">const</span> hasToken = localStorage.getItem(<span class="hljs-string">"token"</span>);

  <span class="hljs-comment">// 已登录</span>
  <span class="hljs-keyword">if</span> (hasToken) {
    <span class="hljs-keyword">if</span> (to.path === <span class="hljs-string">"/login"</span>) {
      <span class="hljs-comment">// 若已登录没有必要显示登录页，重定向至首页</span>
      next({ <span class="hljs-attr">path</span>: <span class="hljs-string">"/"</span> });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 去其他路由，暂时放过</span>
      <span class="hljs-comment">// 接下来执行用户角色逻辑, todo</span>
      <span class="hljs-keyword">const</span> hasRoles =
        store.state.user.roles &amp;&amp; store.state.user.roles.length &gt; <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (hasRoles) {
        next();
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//   请求角色信息</span>
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">const</span> { roles } = <span class="hljs-keyword">await</span> store.dispatch(<span class="hljs-string">"user/getInfo"</span>);

          <span class="hljs-comment">// 动态路由生成，todo</span>
          <span class="hljs-keyword">const</span> accessRoutes = <span class="hljs-keyword">await</span> store.dispatch(
            <span class="hljs-string">"permission/generateRoutes"</span>,
            roles,
          );
          <span class="hljs-comment">//   动态追加到router</span>
          router.addRoutes(accessRoutes);

          <span class="hljs-comment">// 路由在进来一次</span>
          next({ ...to });
        } <span class="hljs-keyword">catch</span> (error) {
          <span class="hljs-comment">// 出错需重置令牌并重新登录（令牌过期、网络错误等原因）</span>
          <span class="hljs-keyword">await</span> store.dispatch(<span class="hljs-string">"user/resetToken"</span>);
          next(<span class="hljs-string">`/login?redirect=<span class="hljs-subst">${to.path}</span>`</span>);
          alert(error || <span class="hljs-string">"未知错误"</span>);
        }
      }
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 未登录</span>
    <span class="hljs-keyword">if</span> (whiteList.indexOf(to.path) !== <span class="hljs-number">-1</span>) {
      <span class="hljs-comment">// 白名单中路由放过</span>
      next();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 重定向至登录页</span>
      next(<span class="hljs-string">`/login?redirect=<span class="hljs-subst">${to.path}</span>`</span>);
    }
  }
});
</code></pre>
<p><code>store.js</code></p>
<ul>
<li>分模块去管理</li>
<li>一个专门管理权限的模块<code>permission</code></li>
<li>一个专门管理用户信息的模块<code>user</code>，包括登录、获取用户全新信息...</li>
</ul>
<pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>
<span class="hljs-keyword">import</span> user <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/user'</span>
<span class="hljs-keyword">import</span> permission <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/permission'</span>

Vue.use(Vuex)

<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store({
  <span class="hljs-attr">modules</span>: {user, permission}
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store
</code></pre>
<p><code>modules/permission.js</code></p>
<ul>
<li>获取到用户权限信息后会进<code>generateRoutes</code>, 拿着该用户的权限信息<code>[&quot;admin&quot;]</code>，所有的权限路由，去对比判断<code>filterAsyncRoutes</code>, 逻辑很简单，定义的路由有<code>meta.roles = ['admin']</code>， 表示这个页面要<code>admin</code>才能访问，获取到的<code>['admin']</code>, 符合条件，过。</li>
</ul>
<pre><code class="hljs css language-js"><span class="hljs-comment">// 1.保存路由表</span>
<span class="hljs-comment">// 2.可以过滤出当前用户可访问的路由表</span>
<span class="hljs-keyword">import</span> { asyncRoutes, constRoutes } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/router"</span>;

<span class="hljs-keyword">const</span> state = {
  <span class="hljs-attr">routes</span>: [], <span class="hljs-comment">// 完整路由表</span>
  addRoutes: [] <span class="hljs-comment">// 用户可访问路由表</span>
};

<span class="hljs-keyword">const</span> mutations = {
  <span class="hljs-attr">SET_ROUTES</span>: <span class="hljs-function">(<span class="hljs-params">state, routes</span>) =&gt;</span> {
    state.addRoutes = routes;
    state.routes = constRoutes.concat(routes);
  }
};

<span class="hljs-keyword">const</span> actions = {
  <span class="hljs-comment">// 路由生成：在得到用户角色后会第一时间调用</span>
  generateRoutes({ commit }, roles) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
      <span class="hljs-comment">// 根据角色做过滤处理</span>
      <span class="hljs-keyword">const</span> accessedRoutes = filterAsyncRoutes(asyncRoutes, roles);;
      commit(<span class="hljs-string">"SET_ROUTES"</span>, accessedRoutes);
      resolve(accessedRoutes);
    });
  }
};

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterAsyncRoutes</span>(<span class="hljs-params">routes, roles</span>) </span>{
  <span class="hljs-keyword">const</span> res = [];
  routes.forEach(<span class="hljs-function"><span class="hljs-params">route</span> =&gt;</span> {
    <span class="hljs-comment">// 复制一份</span>
    <span class="hljs-keyword">const</span> tmp = { ...route };
    <span class="hljs-comment">// 如果用户有访问权则加入结果路由表</span>
    <span class="hljs-keyword">if</span> (hasPermission(roles, tmp)) {
      <span class="hljs-comment">// 如果存在子路由则递归过滤之</span>
      <span class="hljs-keyword">if</span> (tmp.children) {
        tmp.children = filterAsyncRoutes(tmp.children, roles);
      }
      res.push(tmp);
    }
  });

  <span class="hljs-keyword">return</span> res;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasPermission</span>(<span class="hljs-params">roles, route</span>) </span>{
  <span class="hljs-comment">// 如果当前路由有roles字段则需判断用户访问权限</span>
  <span class="hljs-keyword">if</span> (route.meta &amp;&amp; route.meta.roles) {
    <span class="hljs-comment">// 若用户拥有的角色中有被包含在待判定路由角色表中的则拥有访问权</span>
    <span class="hljs-keyword">return</span> roles.some(<span class="hljs-function"><span class="hljs-params">role</span> =&gt;</span> route.meta.roles.includes(role));
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 没有设置roles则无需判定即可访问</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,
  state,
  mutations,
  actions
};
</code></pre>
<p><code>@/router.js</code></p>
<ul>
<li>提前定义好的路由</li>
</ul>
<pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;
<span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-router"</span>;
<span class="hljs-keyword">import</span> Layout <span class="hljs-keyword">from</span> <span class="hljs-string">'@/layout'</span>; <span class="hljs-comment">// 布局页</span>

Vue.use(Router);

<span class="hljs-comment">// 通用页面：不需要守卫，可直接访问</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> constRoutes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">"/login"</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"@/views/Login"</span>),
    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 导航菜单忽略该项</span>
  },
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">"/"</span>,
    <span class="hljs-attr">component</span>: Layout,<span class="hljs-comment">// 应用布局</span>
    redirect: <span class="hljs-string">"/home"</span>,
    <span class="hljs-attr">children</span>: [
      {
        <span class="hljs-attr">path</span>: <span class="hljs-string">"home"</span>,
        <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "home" */</span> <span class="hljs-string">"@/views/Home.vue"</span>),
        <span class="hljs-attr">name</span>: <span class="hljs-string">"home"</span>,
        <span class="hljs-attr">meta</span>: { 
            <span class="hljs-attr">title</span>: <span class="hljs-string">"Home"</span>, <span class="hljs-comment">// 导航菜单项标题</span>
            icon: <span class="hljs-string">"qq"</span> <span class="hljs-comment">// 导航菜单项图标</span>
        }
      }
    ]
  }
];

<span class="hljs-comment">// 权限页面：受保护页面，要求用户登录并拥有访问权限的角色才能访问</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> asyncRoutes = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">"/about"</span>,
    <span class="hljs-attr">component</span>: Layout,
    <span class="hljs-attr">redirect</span>: <span class="hljs-string">"/about/index"</span>,    
    <span class="hljs-attr">children</span>: [
      {
        <span class="hljs-attr">path</span>: <span class="hljs-string">"index"</span>,
        <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "home" */</span> <span class="hljs-string">"@/views/About.vue"</span>),
        <span class="hljs-attr">name</span>: <span class="hljs-string">"about"</span>,
        <span class="hljs-attr">meta</span>: { 
            <span class="hljs-attr">title</span>: <span class="hljs-string">"About"</span>, 
            <span class="hljs-attr">icon</span>: <span class="hljs-string">"qq"</span>,
            <span class="hljs-attr">roles</span>: [<span class="hljs-string">'admin'</span>, <span class="hljs-string">'editor'</span>]
        },
      }
    ]
  }
];

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router({
  <span class="hljs-attr">mode</span>: <span class="hljs-string">"history"</span>,
  <span class="hljs-attr">base</span>: process.env.BASE_URL,
  <span class="hljs-attr">routes</span>: constRoutes
});
</code></pre>
<ul>
<li><p>如果异步获取路由表，思路如下</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-comment">// 前端组件名和组件映射表</span>
<span class="hljs-keyword">const</span> map = { <span class="hljs-attr">login</span>:<span class="hljs-built_in">require</span>(<span class="hljs-string">'login/index'</span>).default <span class="hljs-comment">// 同步的方式 login:()=&gt;import('login/index') // 异步的方式 }</span>
<span class="hljs-comment">// 服务端返回的map类似于</span>
<span class="hljs-keyword">const</span> serviceMap = [
    { <span class="hljs-attr">path</span>: <span class="hljs-string">'/login'</span>, <span class="hljs-attr">component</span>: <span class="hljs-string">'login'</span>, <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> }
]
<span class="hljs-comment">// 遍历serviceMap，将component替换为map[component]，动态生成asyncRoutes function mapComponent(route) {</span>
route.component = serviceMap[route.component];
<span class="hljs-keyword">if</span>(route.children) {
     route.children = route.children.map(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> mapComponent(child))
 }
 <span class="hljs-keyword">return</span> route
}
</code></pre></li>
</ul>
<p><code>modules/user.js</code></p>
<ul>
<li>用户模块</li>
</ul>
<pre><code class="hljs css language-js"><span class="hljs-comment">// 用户状态：登录态、信息</span>
<span class="hljs-keyword">const</span> state = {
  <span class="hljs-attr">token</span>: localStorage.getItem(<span class="hljs-string">"token"</span>),
  <span class="hljs-comment">// 其他用户信息</span>
  roles: [],
};

<span class="hljs-keyword">const</span> mutations = {
  <span class="hljs-attr">SET_TOKEN</span>: <span class="hljs-function">(<span class="hljs-params">state, token</span>) =&gt;</span> {
    state.token = token;
  },
  <span class="hljs-attr">SET_ROLES</span>: <span class="hljs-function">(<span class="hljs-params">state, roles</span>) =&gt;</span> {
    state.roles = roles;
  },
};

<span class="hljs-keyword">const</span> actions = {
  <span class="hljs-comment">// 模拟用户登录</span>
  login({ commit }, userInfo) {
    <span class="hljs-keyword">const</span> { username } = userInfo;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (username === <span class="hljs-string">"admin"</span> || username === <span class="hljs-string">"jerry"</span>) {
          commit(<span class="hljs-string">"SET_TOKEN"</span>, username);
          localStorage.setItem(<span class="hljs-string">"token"</span>, username);
          resolve();
        } <span class="hljs-keyword">else</span> {
          reject(<span class="hljs-string">"用户名、密码错误"</span>);
        }
      }, <span class="hljs-number">1000</span>);
    });
  },
  getInfo({ commit, state }) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> roles = state.token === <span class="hljs-string">"admin"</span> ? [<span class="hljs-string">"admin"</span>] : [<span class="hljs-string">"editor"</span>];
        commit(<span class="hljs-string">"SET_ROLES"</span>, roles);
        resolve({ roles });
      }, <span class="hljs-number">1000</span>);
    });
  },
  resetToken({ commit }) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
      commit(<span class="hljs-string">"SET_TOKEN"</span>, <span class="hljs-string">""</span>);
      commit(<span class="hljs-string">"SET_ROLES"</span>, []);
      localStorage.removeItem(<span class="hljs-string">"token"</span>);
      resolve();
    });
  },
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,
  state,
  mutations,
  actions,
};

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="面包屑"></a><a href="#面包屑" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>面包屑</h3>
<ul>
<li><p>通过 $route.matched 数组动态生成的</p></li>
<li><pre><code class="hljs css language-js">getBreadcrumb() {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$route.matched);
  <span class="hljs-comment">// 面包屑仅显示包含meta.title且item.meta.breadcrumb不为false的路由 </span>
  <span class="hljs-keyword">let</span> matched = <span class="hljs-keyword">this</span>.$route.matched.filter(
    <span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.meta &amp;&amp; item.meta.title &amp;&amp; item.meta.breadcrumb !== <span class="hljs-literal">false</span>
  );
  <span class="hljs-comment">// 根路由</span>
  <span class="hljs-keyword">const</span> first = matched[<span class="hljs-number">0</span>];
  <span class="hljs-comment">// 根匹配只要不是home，就作为home下一级 </span>
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isHome(first)) {
      matched = [{ <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">"/home"</span>, <span class="hljs-attr">meta</span>: { <span class="hljs-attr">title</span>: <span class="hljs-string">"首页"</span> } }].concat(matched);
  }
  <span class="hljs-comment">// 处理完指定到levelList</span>
  <span class="hljs-keyword">this</span>.levelList = matched
},
isHome(route) {
  <span class="hljs-keyword">const</span> name = route &amp;&amp; route.name;
  <span class="hljs-keyword">if</span> (!name) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> name.trim().toLocaleLowerCase() === <span class="hljs-string">"home"</span>.toLocaleLowerCase();
},
handleLink(item) {
  <span class="hljs-keyword">const</span> { redirect, path } = item; <span class="hljs-comment">// 若存在重定向，按重定向走</span>
  <span class="hljs-keyword">if</span> (redirect) {
    <span class="hljs-keyword">this</span>.$router.push(redirect);
    <span class="hljs-keyword">return</span>; 
  }
  <span class="hljs-comment">// 编译path，避免存在路径参数</span>
  <span class="hljs-keyword">this</span>.$router.push(<span class="hljs-keyword">this</span>.pathCompile(path));
},
pathCompile(path) {
  <span class="hljs-keyword">const</span> { params } = <span class="hljs-keyword">this</span>.$route;
  <span class="hljs-keyword">var</span> toPath = pathToRegexp.compile(path);
  <span class="hljs-keyword">return</span> toPath(params);
}
</code></pre></li>
<li><p><code>template</code></p></li>
<li><pre><code class="hljs css language-html"><span class="hljs-tag">&lt;<span class="hljs-name">el-breadcrumb-item</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item,index) in levelList"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.path"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>
  <span class="hljs-attr">v-if</span>=<span class="hljs-string">"item.redirect==='noRedirect'||index==levelList.length-1"</span>
  <span class="hljs-attr">class</span>=<span class="hljs-string">"no-redirect"</span>
  &gt;</span>{{ item.meta.title }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-else</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">"handleLink(item)"</span>&gt;</span>{{ item.meta.title }}<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">el-breadcrumb-item</span>&gt;</span>
</code></pre></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="按钮权限"></a><a href="#按钮权限" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>按钮权限</h3>
<pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">"@/store"</span>;
<span class="hljs-comment">// &lt;button v-permision="['admin','editor']"</span>
<span class="hljs-keyword">const</span> permission = {
  inserted(el, binding) {
    <span class="hljs-comment">// 获取指令的值：按钮要求的角色数组</span>
    <span class="hljs-keyword">const</span> { <span class="hljs-attr">value</span>:pRoles } = binding;
    <span class="hljs-comment">// 获取用户角色</span>
    <span class="hljs-keyword">const</span> roles = store.state.user.roles;

    <span class="hljs-keyword">if</span> (pRoles &amp;&amp; pRoles <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> &amp;&amp; pRoles.length &gt; <span class="hljs-number">0</span>) {      
      <span class="hljs-comment">// 判断用户角色中是否有按钮要求的角色</span>
      <span class="hljs-keyword">const</span> hasPermission = roles.some(<span class="hljs-function"><span class="hljs-params">role</span> =&gt;</span> {
        <span class="hljs-keyword">return</span> pRoles.includes(role);
      });

      <span class="hljs-comment">// 如果没有权限则删除当前dom</span>
      <span class="hljs-keyword">if</span> (!hasPermission) {
        el.parentNode &amp;&amp; el.parentNode.removeChild(el);
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`需要指定按钮要求角色数组，如v-permission="['admin','editor']"`</span>);
    }
  }
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> permission;

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="封装-request"></a><a href="#封装-request" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>封装<code>request</code></h3>
<pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;
<span class="hljs-keyword">import</span> { MessageBox, Message } <span class="hljs-keyword">from</span> <span class="hljs-string">"element-ui"</span>;
<span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">"@/store"</span>;

<span class="hljs-comment">// 创建axios实例</span>
<span class="hljs-keyword">const</span> service = axios.create({
  <span class="hljs-attr">baseURL</span>: process.env.VUE_APP_BASE_API, <span class="hljs-comment">// url基础地址，解决不同数据源url变化问题</span>
  <span class="hljs-comment">// withCredentials: true, // 跨域时若要发送cookies需设置该选项</span>
  timeout: <span class="hljs-number">5000</span> <span class="hljs-comment">// 超时</span>
});

<span class="hljs-comment">// 请求拦截</span>
service.interceptors.request.use(
  <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> {
    <span class="hljs-comment">// do something</span>
    <span class="hljs-keyword">const</span> token = localStorage.getItem(<span class="hljs-string">'token'</span>)
    <span class="hljs-keyword">if</span> (token) {
      <span class="hljs-comment">// 设置令牌请求头</span>
      config.headers[<span class="hljs-string">"Authorization"</span>] = <span class="hljs-string">'Bearer '</span> + token;
    }
    <span class="hljs-keyword">return</span> config;
  },
  error =&gt; {
    <span class="hljs-comment">// 请求错误预处理</span>
    <span class="hljs-comment">//console.log(error) // for debug</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);
  }
);

<span class="hljs-comment">// 响应拦截</span>
service.interceptors.response.use(
  <span class="hljs-comment">// 通过自定义code判定响应状态，也可以通过HTTP状态码判定</span>
  <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-comment">// 仅返回数据部分</span>
    <span class="hljs-keyword">const</span> res = response.data;

    <span class="hljs-comment">// code不为1则判定为一个错误</span>
    <span class="hljs-keyword">if</span> (res.code !== <span class="hljs-number">1</span>) {
      Message({
        <span class="hljs-attr">message</span>: res.message || <span class="hljs-string">"Error"</span>,
        <span class="hljs-attr">type</span>: <span class="hljs-string">"error"</span>,
        <span class="hljs-attr">duration</span>: <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>
      });

      <span class="hljs-comment">// 假设：10008-非法令牌; 10012-其他客户端已登录; 10014-令牌过期;</span>
      <span class="hljs-keyword">if</span> (res.code === <span class="hljs-number">10008</span> || res.code === <span class="hljs-number">10012</span> || res.code === <span class="hljs-number">10014</span>) {
        <span class="hljs-comment">// 重新登录</span>
        MessageBox.confirm(
          <span class="hljs-string">"登录状态异常，请重新登录"</span>,
          <span class="hljs-string">"确认登录信息"</span>,
          {
            <span class="hljs-attr">confirmButtonText</span>: <span class="hljs-string">"重新登录"</span>,
            <span class="hljs-attr">cancelButtonText</span>: <span class="hljs-string">"取消"</span>,
            <span class="hljs-attr">type</span>: <span class="hljs-string">"warning"</span>
          }
        ).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          store.dispatch(<span class="hljs-string">"user/resetToken"</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            location.reload();
          });
        });
      }
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(res.message || <span class="hljs-string">"Error"</span>));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> res;
    }
  },
  error =&gt; {
    <span class="hljs-comment">//console.log("err" + error); // for debug</span>
    Message({
      <span class="hljs-attr">message</span>: error.message,
      <span class="hljs-attr">type</span>: <span class="hljs-string">"error"</span>,
      <span class="hljs-attr">duration</span>: <span class="hljs-number">5</span> * <span class="hljs-number">1000</span>
    });
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);
  }
);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> service;

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="代理配置"></a><a href="#代理配置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代理配置</h3>
<p><code>vue.config.js</code></p>
<pre><code class="hljs css language-js">devServer: {
    <span class="hljs-attr">port</span>: port,
    <span class="hljs-attr">proxy</span>: {
    <span class="hljs-comment">// 代理 /dev-api/user/login 到 http://127.0.0.1:3000/user/login [process.env.VUE_APP_BASE_API]: {</span>
      target: <span class="hljs-string">`http://127.0.0.1:3000/`</span>,
      <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">pathRewrite</span>: {
            [<span class="hljs-string">"^"</span> + process.env.VUE_APP_BASE_API]: <span class="hljs-string">""</span>
      }
    }},
}
</code></pre>
<p><code>.env.development</code></p>
<pre><code class="hljs"><span class="hljs-meta"># base api</span>
<span class="hljs-meta"># VUE_APP_BASE_API = '/dev-api'</span>
VUE_APP_BASE_API = 'http://127.0.0.1:<span class="hljs-number">7300</span>/mock/5d786f7c8d7eac40b82e<span class="hljs-number">9538</span>/vue-study'
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="测试"></a><a href="#测试" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>测试</h3>
<ul>
<li>不管内部实现机制，只看最外层的输入输出，这种我们称为<strong>黑 盒测试</strong></li>
<li>写一个加法的页面，会设计N个用例，测试加法的正确性，这种测试我们称之为<strong>E2E****测 试</strong></li>
<li>针对一些内部核心实现逻辑编写测试代码，称之为<strong>单元测试</strong></li>
<li>集合多个测试过的单元一起测试，称之为<strong>集成测试</strong></li>
<li><strong>编写测试代码的好处</strong>
<ul>
<li>提供描述组件行为的文档</li>
<li>节省手动测试的时间</li>
<li>减少研发新特性时产生的 bug改进设计</li>
<li>促进重构</li>
</ul></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="mocha-chai"></a><a href="#mocha-chai" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>Mocha +Chai</code></h4>
<ul>
<li><p>在vue中，推荐用<strong>Mocha+Chai</strong>或者Jest，演示代码使用Jest，它们语法基本一致</p></li>
<li><p>上面的Mocha是测试框架，Chai是断言库，Jest同时包含两者</p></li>
<li><p>vue中的组件等测试代码的编写需要vue-test-utils套件支持</p></li>
<li><p><strong>新建****vue项目时</strong>：</p>
<ul>
<li>选择特性 Unit Testing 和 E2E Testing</li>
<li>单元测试解决方案选择: Jest</li>
<li>端到端测试解决方案选择:Cypress</li>
</ul></li>
<li><p><strong>在已存在项目中集成</strong></p>
<ul>
<li>运行: vue add @vue/unit-jest 和 vue add @vue/e2e-cypress</li>
</ul></li>
<li><p><strong>编写单元测试</strong></p>
<ul>
<li><p>单元测试(unit testing)，是指对软件中的最小可测试单元进行检查和验证。</p></li>
<li><p>新建test/unit/kaikeba.spec.js， *.spec.js 是命名规范</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>{
    <span class="hljs-keyword">return</span> num1 + num2
}
<span class="hljs-comment">// 测试套件 test suite </span>
describe(<span class="hljs-string">'testA'</span>, () =&gt; {
<span class="hljs-comment">// 测试用例 test case </span>
  it(<span class="hljs-string">'测试add函数'</span>, () =&gt; {
    <span class="hljs-comment">// 断言 assert </span>
        expect(add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)).toBe(<span class="hljs-number">3</span>) 
    expect(add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)).toBe(<span class="hljs-number">4</span>) 
    expect(add(<span class="hljs-number">-2</span>, <span class="hljs-number">3</span>)).toBe(<span class="hljs-number">1</span>)
  }) 
})
</code></pre></li>
</ul></li>
<li><p><strong>执行单元测试</strong></p>
<ul>
<li>执行: <code>npm run test:unit</code></li>
</ul></li>
<li><p><strong>断言****API****简介</strong></p>
<ul>
<li>describe : 定义一个测试套件</li>
<li>it :定义一个测试用例</li>
<li>expect :断言的判断条件</li>
</ul></li>
<li><p><strong>测试****Vue****组件</strong></p>
<ul>
<li><p>vue官方提供了用于单元测试的实用工具库 @vue/test-utils</p></li>
<li><p>创建一个vue组件components/testA.vue</p></li>
<li><pre><code class="hljs css language-js">&lt;template&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"changeMsg"</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    data () {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-string">'vue-text'</span>
            } 
    },
    created () { 
      <span class="hljs-keyword">this</span>.message = <span class="hljs-string">'a'</span>
    }, 
    <span class="hljs-attr">methods</span>:{
      changeMsg(){
        <span class="hljs-keyword">this</span>.message = <span class="hljs-string">'按钮点击'</span>
      } 
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre></li>
<li><p>测试该组件，test/unit/testA.spec.js</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> testA <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/testA.vue'</span>
describe(<span class="hljs-string">'testA.vue'</span>, () =&gt; {
    <span class="hljs-comment">// 检查组件选项 </span>
  it(<span class="hljs-string">'要求设置created生命周期'</span>, () =&gt; {
    expect(<span class="hljs-keyword">typeof</span> testA.created).toBe(<span class="hljs-string">'function'</span>)
  })
    it(<span class="hljs-string">'message初始值是vue-test'</span>, () =&gt; {
        <span class="hljs-comment">// 检查data函数存在性</span>
        expect(<span class="hljs-keyword">typeof</span> testA.data).toBe(<span class="hljs-string">'function'</span>) <span class="hljs-comment">// 检查data返回的默认值</span>
    <span class="hljs-keyword">const</span> defaultData = testA.data()
    expect(defaultData.message).toBe(<span class="hljs-string">'vue-test'</span>)
  })
})
</code></pre></li>
</ul></li>
<li><p><strong>测试覆盖率</strong></p>
<ul>
<li><p>jest自带覆盖率，如果用的mocha，需要使用istanbul来统计覆盖率</p></li>
<li><p>package.json里修改jest配置</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-string">"jest"</span>: {
    <span class="hljs-string">"collectCoverage"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">"collectCoverageFrom"</span>: [<span class="hljs-string">"src/**/*.{js,vue}"</span>],
}
</code></pre></li>
</ul></li>
<li><p><a href="https://vue-test-utils.vuejs.org/zh/">Vue Test Utils使用指南</a></p></li>
<li><p><a href="https://cn.vuejs.org/v2/cookbook/unit-testing-vue-components.html">Vue组件单元测试cookbook</a></p></li>
<li><p><a href="https://jestjs.io/docs/zh-Hans/expect">断言API</a></p></li>
<li><p><strong>E2E****测试</strong></p>
<ul>
<li><p>借用浏览器的能力，站在用户测试人员的角度，输入框，点击按钮等，完全模拟用户，这个和具体的框
架关系不大，完全模拟浏览器行为</p></li>
<li><p><strong>运行****E2E****测试</strong></p></li>
<li><pre><code class="hljs css language-js">npm run test:e2e
</code></pre></li>
<li><p>修改e2e/spec/test.js</p></li>
<li><pre><code class="hljs css language-js">describe(<span class="hljs-string">'端到端测试'</span>, () =&gt; { 
    it(<span class="hljs-string">'先访问一下'</span>, () =&gt; {
        cy.visit(<span class="hljs-string">'/'</span>)
        <span class="hljs-comment">// cy.contains('h1', 'Welcome to Your Vue.js App') </span>
        cy.contains(<span class="hljs-string">'span'</span>, <span class="hljs-string">'hello'</span>)
        cy.get(<span class="hljs-string">'button'</span>).click()
        cy.contains(<span class="hljs-string">'span'</span>, <span class="hljs-string">'按钮点击'</span>)
    }) 
})
</code></pre></li>
</ul></li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2020/08/15/对象转内联样式">对象转内联样式</a></h1><p class="post-meta">August 15, 2020</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="源码链接"></a><a href="#源码链接" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码链接</h3>
<p><a href="https://github.com/NervJS/taro/blob/master/packages/taro/src/internal/inline-style.js">跳转</a></p>
<h3><a class="anchor" aria-hidden="true" id="代码"></a><a href="#代码" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代码</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> upperCasePattern = <span class="hljs-regexp">/([A-Z])/g</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dashify</span> (<span class="hljs-params">str</span>) </span>{
  <span class="hljs-keyword">return</span> str.replace(upperCasePattern, dashLower)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dashLower</span> (<span class="hljs-params">c</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'-'</span> + c.toLowerCase()
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">return</span> val != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-built_in">Array</span>.isArray(val) === <span class="hljs-literal">false</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inlineStyle</span> (<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">return</span> obj
  }

  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || obj === <span class="hljs-literal">undefined</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
  }

  <span class="hljs-keyword">if</span> (!isObject(obj)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'style 只能是一个对象或字符串。'</span>)
  }
  <span class="hljs-comment">// [{backgroundColor: 'red'}] =&gt; 'background-color:red;'</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(obj).map(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> dashify(key).concat(<span class="hljs-string">':'</span>).concat(obj[key])).join(<span class="hljs-string">';'</span>)

}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="测试"></a><a href="#测试" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>测试</h3>
<p><img src="https://raw.githubusercontent.com/stupidWall/liuxiaobai/master/img/blog/2019/20190814115913.jpg" /></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/10/23/SSR">服务端渲染SSR</a></h1><p class="post-meta">October 23, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h4><a class="anchor" aria-hidden="true" id="资源"></a><a href="#资源" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>资源</h4>
<ul>
<li><a href="https://ssr.vuejs.org/zh/">vue ssr</a></li>
<li><a href="https://nuxtjs.org/">nuxt.js</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="ssr"></a><a href="#ssr" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SSR</h3>
<ul>
<li><p>友好SEO</p></li>
<li><p>首屏快</p></li>
<li><p>单页面SPA： 访问<code>url</code>， 返回<code>html</code>结构,没有<code>dom</code>结构，<code>js vue</code>，渲染<code>template</code>,  要数据，拿到<code>json</code>。 毛病是首屏慢</p></li>
<li><p>传统服务端渲染： 访问<code>url</code>, 拼接<code>html</code>字符串模版，响应<code>html</code>， 渲染<code>html</code>， 毛病是每次请求都刷新，流量消耗大</p></li>
<li><p>SSR解决上面2问题： 后段渲染出完成首屏<code>dom</code>结构返回，前端拿到的包括首屏结构和完整<code>spa</code>结构， 应用激活后，依然按照<code>spa</code>方式运行</p></li>
<li><p>缺点：开发复杂度增加，开发条件复杂，其他库不处理可能不能运行，部署起来麻烦， 基于<code>node</code>， 起到中间件作用</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="实战"></a><a href="#实战" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实战</h4>
<ul>
<li><p>新建工程<code>vue create ssr</code></p></li>
<li><p>安装依赖<code>npm install vue-server-renderer express -D</code></p></li>
<li><p>启动脚本</p>
<ul>
<li><p>创建<code>expresss</code>服务器</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)
<span class="hljs-keyword">const</span> Vue = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vue'</span>)

<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> page = <span class="hljs-keyword">new</span> Vue({
    <span class="hljs-attr">data</span>: {<span class="hljs-attr">name</span>:<span class="hljs-string">'标题'</span>},
    <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;div&gt;{{name}}&lt;/div&gt;'</span>
})

<span class="hljs-comment">// 1.渲染器</span>
<span class="hljs-keyword">const</span> renderer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vue-server-renderer'</span>).createRenderer();

app.get(<span class="hljs-string">'/'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>{
    <span class="hljs-comment">// 2.执行渲染</span>
    <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> renderer.renderToString(page)
    res.send(html);
})

app.listen(<span class="hljs-number">3000</span>, () =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'渲染服务器就绪'</span>);
})
</code></pre></li>
</ul></li>
<li><p>路由： 路由支持仍然使用vue-router</p>
<ul>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;
<span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">"vue-router"</span>;
<span class="hljs-comment">// 分别创建Index.vue和Detail.vue</span>
<span class="hljs-keyword">import</span> Index <span class="hljs-keyword">from</span> <span class="hljs-string">"@/views/Index"</span>;
<span class="hljs-keyword">import</span> Detail <span class="hljs-keyword">from</span> <span class="hljs-string">"@/views/Detail"</span>;

Vue.use(Router);

<span class="hljs-comment">//导出工厂函数</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRouter</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Router({
    <span class="hljs-attr">mode</span>: <span class="hljs-string">'history'</span>,
    <span class="hljs-attr">routes</span>: [
      { <span class="hljs-attr">path</span>: <span class="hljs-string">"/"</span>, <span class="hljs-attr">component</span>: Index },
      { <span class="hljs-attr">path</span>: <span class="hljs-string">"/detail"</span>, <span class="hljs-attr">component</span>: Detail }
    ]
  });
}
</code></pre></li>
</ul></li>
<li><p>构建</p>
<ul>
<li><p>对于客户端应用程序和服务器应用程序，我们都要使用 webpack 打包 - 服务器需要「服务器 bundle」 然后用于服务器端渲染(SSR)，而「客户端 bundle」会发送给浏览器，用于混合静态标记</p></li>
<li><p>构建流程</p>
<ul>
<li></li>
</ul></li>
<li><pre><code class="hljs">src
├── App.vue
├── app.<span class="hljs-keyword">js </span><span class="hljs-comment"># 用于创建vue实例</span>
├── entry-client.<span class="hljs-keyword">js </span><span class="hljs-comment"># 客户端入口，用于静态内容“激活”</span>
└── entry-server.<span class="hljs-keyword">js </span><span class="hljs-comment"># 服务端入口，用于首屏内容渲染</span>
</code></pre></li>
<li><p><code>app.js</code></p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-comment">// 创建Vue实例</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-keyword">import</span> {createRouter} <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span>

<span class="hljs-comment">// 客户端挂载之前，检查组件是否存在异步数据获取</span>
Vue.mixin({
    beforeMount() {
      <span class="hljs-keyword">const</span> { asyncData } = <span class="hljs-keyword">this</span>.$options;
      <span class="hljs-keyword">if</span> (asyncData) {
        <span class="hljs-comment">// 将获取数据操作分配给 promise</span>
        <span class="hljs-comment">// 以便在组件中，我们可以在数据准备就绪后</span>
        <span class="hljs-comment">// 通过运行 `this.dataPromise.then(...)` 来执行其他任务</span>
        <span class="hljs-keyword">this</span>.dataPromise = asyncData({
          <span class="hljs-attr">store</span>: <span class="hljs-keyword">this</span>.$store,
          <span class="hljs-attr">route</span>: <span class="hljs-keyword">this</span>.$route,
        });
      }
    },
  });

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createApp</span>(<span class="hljs-params">context</span>) </span>{
    <span class="hljs-comment">// 1.获取路由实例</span>
    <span class="hljs-keyword">const</span> router = createRouter();
    <span class="hljs-comment">// 2.获取store实例</span>
    <span class="hljs-keyword">const</span> store = createStore()
    <span class="hljs-comment">// 2.创建vue实例</span>
    <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue({
        router,
        store,
        context,
        <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)
    })
    <span class="hljs-keyword">return</span> {app, router, store}
}
</code></pre></li>
<li><p><code>src/entry-server.js</code> 服务端入口, 首屏</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-comment">// 创建vue实例并且做首屏渲染</span>
<span class="hljs-keyword">import</span> {createApp} <span class="hljs-keyword">from</span> <span class="hljs-string">'./app'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> context =&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> {app,router,store} = createApp(context)
        <span class="hljs-comment">// 跳转首屏</span>
        router.push(context.url)
        router.onReady(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-comment">// 获取匹配的路由组件数组</span>
            <span class="hljs-keyword">const</span> matchedComponents = router.getMatchedComponents();
            <span class="hljs-keyword">if</span> (!matchedComponents.length) {
              <span class="hljs-keyword">return</span> reject({ <span class="hljs-attr">code</span>: <span class="hljs-number">404</span> });
            }
            
            <span class="hljs-comment">// 对所有匹配的路由组件调用 `asyncData()`</span>
            <span class="hljs-built_in">Promise</span>.all(
              matchedComponents.map(<span class="hljs-function"><span class="hljs-params">Component</span> =&gt;</span> {
                <span class="hljs-keyword">if</span> (Component.asyncData) {
                  <span class="hljs-keyword">return</span> Component.asyncData({
                    store,
                    <span class="hljs-attr">route</span>: router.currentRoute,
                  });
                }
              }),
            )
              .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
                <span class="hljs-comment">// 所有预取钩子 resolve 后，</span>
                <span class="hljs-comment">// store 已经填充入渲染应用所需状态</span>
                <span class="hljs-comment">// 将状态附加到上下文，且 `template` 选项用于 renderer 时，</span>
                <span class="hljs-comment">// 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。</span>
                context.state = store.state;
                  
                resolve(app);
              })
              .catch(reject);
          }, reject);
    })
}
</code></pre></li>
<li><p><code>entry-client.js</code>客户端入口， 激活</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">// 客户端激活</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">"./app"</span>;

<span class="hljs-keyword">const</span> { app, router, store } = createApp();

<span class="hljs-comment">// 当使用 template 时，context.state 将作为 window.__INITIAL_STATE__ 状态自动嵌入到最终的 HTML // 在客户端挂载到应用程序之前，store 就应该获取到状态：</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.__INITIAL_STATE__) {
  store.replaceState(<span class="hljs-built_in">window</span>.__INITIAL_STATE__);
}

router.onReady(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-comment">// 激活</span>
  app.$mount(<span class="hljs-string">"#app"</span>);
});

</code></pre></li>
</ul></li>
<li><p><code>webpack</code>配置</p>
<ul>
<li><p><code>vue.config.js</code></p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> VueSSRServerPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vue-server-renderer/server-plugin"</span>);
<span class="hljs-keyword">const</span> VueSSRClientPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vue-server-renderer/client-plugin"</span>);

<span class="hljs-keyword">const</span> TARGET_NODE = process.env.WEBPACK_TARGET === <span class="hljs-string">"node"</span>;
<span class="hljs-keyword">const</span> target = TARGET_NODE ? <span class="hljs-string">"server"</span> : <span class="hljs-string">"client"</span>;

<span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">css</span>: {
    <span class="hljs-attr">extract</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">outputDir</span>: <span class="hljs-string">'./dist/'</span>+target,
  <span class="hljs-attr">configureWebpack</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
    <span class="hljs-comment">// 将 entry 指向应用程序的 server / client 文件</span>
    entry: <span class="hljs-string">`./src/entry-<span class="hljs-subst">${target}</span>.js`</span>,
    <span class="hljs-comment">// 对 bundle renderer 提供 source map 支持</span>
    devtool: <span class="hljs-string">'source-map'</span>,
    <span class="hljs-comment">// 这允许 webpack 以 Node 适用方式处理动态导入(dynamic import)，</span>
    <span class="hljs-comment">// 并且还会在编译 Vue 组件时告知 `vue-loader` 输送面向服务器代码(server-oriented code)。</span>
    target: TARGET_NODE ? <span class="hljs-string">"node"</span> : <span class="hljs-string">"web"</span>,
    <span class="hljs-attr">node</span>: TARGET_NODE ? <span class="hljs-literal">undefined</span> : <span class="hljs-literal">false</span>,
    <span class="hljs-attr">output</span>: {
      <span class="hljs-comment">// 此处使用 Node 风格导出模块</span>
      libraryTarget: TARGET_NODE ? <span class="hljs-string">"commonjs2"</span> : <span class="hljs-literal">undefined</span>
    },
    <span class="hljs-comment">// 这是将服务器的整个输出构建为单个 JSON 文件的插件。</span>
    <span class="hljs-comment">// 服务端默认文件名为 `vue-ssr-server-bundle.json`</span>
    plugins: [TARGET_NODE ? <span class="hljs-keyword">new</span> VueSSRServerPlugin() : <span class="hljs-keyword">new</span> VueSSRClientPlugin()]
  })
};
</code></pre></li>
<li><p>脚本 <code>package.json</code></p></li>
<li><pre><code class="hljs"><span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"build:client"</span>: <span class="hljs-string">"vue-cli-service build"</span>,
    <span class="hljs-string">"build:server"</span>: <span class="hljs-string">"cross-env WEBPACK_TARGET=node vue-cli-service build --mode server"</span>,
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"npm run build:server &amp;&amp; npm run build:client"</span>,
  },
</code></pre></li>
</ul></li>
<li><p>宿主文件</p>
<ul>
<li><p>最后需要定义宿主文件，创建./public/index.tmpl.html</p></li>
<li><pre><code class="hljs css language-html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!--vue-ssr-outlet--&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre></li>
</ul></li>
<li><p>服务器启动文件<code>server/index2.js</code></p>
<ul>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)

<span class="hljs-keyword">const</span> app = express();

<span class="hljs-comment">// 1.渲染器</span>
<span class="hljs-keyword">const</span> {createBundleRenderer} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vue-server-renderer'</span>);
<span class="hljs-keyword">const</span> bundle = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../dist/server/vue-ssr-server-bundle.json'</span>)

app.use(express.static(<span class="hljs-string">'../dist/client'</span>, {<span class="hljs-attr">index</span>: <span class="hljs-literal">false</span>}))

<span class="hljs-comment">// bundle是服务端包</span>
<span class="hljs-keyword">const</span> renderer = createBundleRenderer(bundle, {
    <span class="hljs-attr">runInNewContext</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">template</span>: fs.readFileSync(<span class="hljs-string">'../public/index.tmpl.html'</span>, <span class="hljs-string">"utf-8"</span>),
    <span class="hljs-attr">clientManifest</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'../dist/client/vue-ssr-client-manifest.json'</span>)
})

app.get(<span class="hljs-string">'*'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
    <span class="hljs-built_in">console</span>.log(req.url);
    
    <span class="hljs-keyword">const</span> context = {
        <span class="hljs-attr">title</span>: <span class="hljs-string">'SSR Test'</span>,
        <span class="hljs-attr">url</span>: req.url
    }

    <span class="hljs-comment">// 2.执行渲染</span>
    <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> renderer.renderToString(context)
    res.send(html);
})

app.listen(<span class="hljs-number">3000</span>, () =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'渲染服务器就绪'</span>);
    
})
</code></pre></li>
<li></li>
</ul></li>
<li><p>整合<code>Vuex</code></p>
<ul>
<li><p><code>store.js</code></p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">"vue"</span>;
<span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">"vuex"</span>;

Vue.use(Vuex);

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStore</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vuex.Store({
    <span class="hljs-attr">state</span>: {
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
    },
    <span class="hljs-attr">mutations</span>: {
      add(state) {
        state.count += <span class="hljs-number">1</span>;
      },
      init(state, count) {
        state.count = count;
      },
    },
    <span class="hljs-attr">actions</span>: {
      <span class="hljs-comment">// 加一个异步请求count的action</span>
      getCount({ commit }) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
          setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            commit(<span class="hljs-string">"init"</span>, <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>);
            resolve();
          }, <span class="hljs-number">1000</span>);
        });
      },
    },
  });
}
</code></pre></li>
<li><p>挂载 <code>app.js</code></p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createApp</span> (<span class="hljs-params">context</span>) </span>{ <span class="hljs-comment">// 创建实例</span>
    <span class="hljs-keyword">const</span> store = createStore()
    <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue({
                store, <span class="hljs-comment">// 挂载</span>
        render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)
    })
    <span class="hljs-keyword">return</span> { app, router, store }
}
</code></pre></li>
<li><p>使用<code>src/components/Index.vue</code></p></li>
<li><pre><code class="hljs css language-js">&lt;h2&gt;num:{{$store.state.count}}&lt;/h2&gt;
&lt;button @click="$store.commit('add')"&gt;add&lt;/button&gt;
</code></pre></li>
</ul></li>
</ul>
<ul>
<li><p><code>Next.js</code></p>
<ul>
<li><p>基于<code>vue.js</code>的通用应用框架</p></li>
<li><p>安装：<code>npx create-nuxt-app 项目名</code></p></li>
<li><p>运行：<code>npm run dev</code></p></li>
<li><p>路由</p>
<ul>
<li>pages目录中所有 *.vue 文件自动生成应用的路由配置，新建:
<ul>
<li>pages/admin.vue 商品管理页</li>
<li>pages/login.vue 登录页</li>
</ul></li>
<li>查看.nuxt/router.js验证生成路由</li>
</ul></li>
<li><p><strong>动态路由</strong></p>
<ul>
<li><p><strong>下划线作为前缀</strong>的 .vue文件 或 目录会被定义为动态路由，如下面文件结构。 如果detail/里面不存在index.vue，:id将被作为可选参数</p>
<ul>
<li><pre><code class="hljs">pages/
-<span class="ruby">-<span class="hljs-params">| detail/
</span></span>-<span class="ruby"><span class="hljs-params">---|</span> _id.vue
</span></code></pre></li>
</ul></li>
</ul></li>
<li><p><strong>嵌套路由</strong></p>
<ul>
<li><p>创建内嵌子路由，你需要添加一个 .vue 文件，同时添加一个<strong>与该文件同名</strong>的目录用来存放子视图组 件。</p>
<ul>
<li><pre><code class="hljs">pages/
-<span class="ruby">-<span class="hljs-params">| detail/
</span></span>-<span class="ruby"><span class="hljs-params">---|</span> _id.vue
</span>-<span class="ruby">-<span class="hljs-params">| detail.vue
</span></span></code></pre></li>
</ul></li>
</ul></li>
<li><p>扩展路由</p>
<ul>
<li><p>要扩展 Nuxt.js 创建的路由，可以通过 router.extendRoutes 选项配置。例如添加自定义路由:</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-comment">// nuxt.config.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">router</span>: {
      extendRoutes (routes, resolve) {
        routes.push({
          <span class="hljs-attr">name</span>: <span class="hljs-string">"foo"</span>,
          <span class="hljs-attr">path</span>: <span class="hljs-string">"/foo"</span>,
          <span class="hljs-attr">component</span>: resolve(__dirname, <span class="hljs-string">"pages/custom.vue"</span>)
          }); 
      }
  } 
}
</code></pre></li>
</ul></li>
<li><p><strong>整合****axios</strong></p>
<ul>
<li><p>安装@nuxt/axios模块: npm install @nuxtjs/axios -S</p></li>
<li><p>配置:nuxt.config.js</p></li>
<li><pre><code class="hljs css language-js">modules: [
    <span class="hljs-string">'@nuxtjs/axios'</span>,
], <span class="hljs-attr">axios</span>: {
    <span class="hljs-attr">proxy</span>: <span class="hljs-literal">true</span>
},
<span class="hljs-attr">proxy</span>: {
    <span class="hljs-string">"/api"</span>: <span class="hljs-string">"http://localhost:8080"</span>
},
</code></pre></li>
</ul></li>
<li><p><strong>异步数据获取</strong></p>
<ul>
<li>asyncData 方法使得我们可以在<strong>设置组件数据之前异步获取或处理数据</strong>。</li>
</ul></li>
<li><p><strong>中间件</strong></p>
<ul>
<li><p>中间件会在一个页面或一组页面渲染之前运行我们定义的函数，常用于权限控制、校验等任务。</p></li>
<li><p>管理员页面保护，创建middleware/auth.js</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{ route, redirect, store }</span>) </span>{ 
  <span class="hljs-comment">// 上下文中通过store访问vuex中的全局状态</span>
<span class="hljs-comment">// 通过vuex中令牌存在与否判断是否登录</span>
<span class="hljs-keyword">if</span> (!store.state.user.token) {
    redirect(<span class="hljs-string">"/login?redirect="</span>+route.path);
  }
}
</code></pre></li>
<li><p>注册中间件，admin.vue</p></li>
<li><pre><code class="hljs css language-js">&lt;script&gt;
    export default {
        middleware: ['auth']
}
&lt;/script&gt;
</code></pre></li>
<li><p>全局注册:将会对所有页面起作用，nuxt.config.js</p></li>
<li><pre><code class="hljs css language-js">router: {
    <span class="hljs-attr">middleware</span>: [<span class="hljs-string">'auth'</span>]
},
</code></pre></li>
</ul></li>
<li><p><strong>发布部署</strong></p></li>
<li><p><strong>静态应用部署</strong></p>
<ul>
<li><p>Nuxt.js 可依据路由配置将应用静态化，使得我们可以将应用部署至任何一个静态站点主机服务商。</p></li>
<li><pre><code class="hljs css language-js">npm run generate
</code></pre></li>
<li><p>注意渲染和接口服务器都需要处于启动状态, 生成内容再dist中</p></li>
</ul></li>
<li><p>插件</p>
<ul>
<li><p>Nuxt.js会在运行应用之前执行插件函数，需要引入或设置Vue插件、自定义模块和第三方模块时特别有用</p></li>
<li><p>接口注入，利用插件机制将服务接口注入组件实例、store实例中，创建plugins/api- inject.js</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ({ $axios }, inject) =&gt; {
  inject(<span class="hljs-string">"login"</span>, user =&gt; {
    <span class="hljs-keyword">return</span> $axios.$post(<span class="hljs-string">"/api/login"</span>, user);
  });
};
</code></pre></li>
<li><p>注册插件，nuxt.config.js</p></li>
<li><pre><code class="hljs css language-js">plugins: [
    <span class="hljs-string">"@/plugins/api-inject"</span>
],
</code></pre></li>
<li><p>添加请求拦截器附加token，创建plugins/interceptor.js</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">{ $axios, store }</span>) </span>{
  $axios.onRequest(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (store.state.user.token) {
      config.headers.Authorization = <span class="hljs-string">"Bearer "</span> + store.state.user.token;
}
    <span class="hljs-keyword">return</span> config;
  });
}
</code></pre></li>
<li><p>注册插件，nuxt.config.js</p></li>
<li><pre><code class="hljs css language-js">plugins: [<span class="hljs-string">"@/plugins/interceptor"</span>]
</code></pre></li>
<li><p><strong>nuxtServerInit</strong></p>
<ul>
<li><p>当我们想将服务端的一些数据传到客户端时，这个方法非常好用。</p></li>
<li><p>登录状态初始化，store/index.js</p></li>
<li><pre><code class="hljs css language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> actions = {
<span class="hljs-comment">// 参数1:action上下文对象，参数2:页面上下文 nuxtServerInit({ commit }, { app }) {</span>
    <span class="hljs-keyword">const</span> token = app.$cookies.get(<span class="hljs-string">"token"</span>);
    <span class="hljs-keyword">if</span> (token) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"nuxtServerInit: token:"</span>+token);
      commit(<span class="hljs-string">"user/init"</span>, token);
    }
} };
</code></pre></li>
<li><p>安装依赖模块:cookie-universal-nuxt <code>npm i -S cookie-universal-nuxt</code></p></li>
<li><p>注册, nuxt.config.js</p></li>
<li><pre><code class="hljs"><span class="hljs-symbol">modules:</span> [<span class="hljs-string">"cookie-universal-nuxt"</span>],
</code></pre></li>
<li><pre><code class="hljs">nuxtServerInit只能写在store/index<span class="hljs-selector-class">.js</span> 
nuxtServerInit仅在服务端执行
</code></pre></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/10/11/vue双向绑定">vue双向绑定原理</a></h1><p class="post-meta">October 11, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><ul>
<li><p>首先，我要想办法把<code>data</code>里的属性观察起来，我叫一个哥们<code>o</code>， 让他帮忙我把做这件事</p></li>
<li><p>哥们<code>o</code>说：我有一个办法，我用<code>Object.defineProperty</code>,可以 把你<code>data</code>下的属性观察起来，现在我可以保证的是，你访问或设置<code>data</code>下的属性, 我都能观察到， 至于观察到之后做什么，你自己看着办。 重点是你得告诉我观察谁，是对象才能给你观察， 现在你只告诉我是<code>data</code>， 目前我只观察着它，其他没观察到不关我事</p></li>
<li><pre><code class="hljs css language-js">observe(value) {
  <span class="hljs-built_in">Object</span>.keys(value).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
    <span class="hljs-comment">// 执行响应化</span>
    <span class="hljs-keyword">this</span>.defineReactive(value, key, value[key])
  })
}

defineReactive(obj, key, val) {
  <span class="hljs-comment">// 定义属性</span>
  <span class="hljs-comment">// 参数3是属性描述符，定义配置型、遍历性、可读、可写</span>
  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, {
    <span class="hljs-keyword">get</span>() {
      <span class="hljs-comment">// todo...</span>
      <span class="hljs-keyword">return</span> val;
    },
    <span class="hljs-keyword">set</span>(newVal) {
      <span class="hljs-keyword">if</span> (newVal === val) {
        <span class="hljs-keyword">return</span>
      }
      <span class="hljs-comment">// todo...</span>
      val = newVal;
    }
  })
}
</code></pre></li>
<li><p><code>this.data[key]</code>这样访问太麻烦，我得找个人帮我，可以直接访问或设置<code>this[key]</code>,这时哥们<code>p</code>举手了</p></li>
<li><p>哥们<code>p</code>说： 这样吧，你访问<code>this[key]</code>时，我给你转发到<code>this.data[key]</code>上去，你放心这样用吧</p></li>
<li><pre><code class="hljs css language-js">proxyData(key) {
  <span class="hljs-comment">// 想Vue实例上面定义属性key</span>
  <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, key, {
    <span class="hljs-keyword">get</span>() {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$data[key]
    },
    <span class="hljs-keyword">set</span>(newVal) {
      <span class="hljs-keyword">this</span>.$data[key] = newVal;
    }
  })
}
</code></pre></li>
<li><p><code>data</code>里的数据用在<code>template</code>模版上的， 模版上直接<code>{{attr1}}</code>就能读取，直接<code>v-model</code>就能跟<code>input</code>搭配起来用，用起来方便极了，问题是我得找人帮忙搞出来，叫哥们<code>c</code>帮我编译模版吧</p></li>
<li><p>哥们<code>c</code>说：这活不好干，你告诉我是那个节点<code>el</code>下的<code>template</code>吧，我试试看。<code>c</code>回去后自己嘀咕着： 老大让我干啥来着？<code>{{attr1}}</code>能读取到啊， 读取？ 不行，得让老大告诉我<code>vm</code>， 不然我上哪知道，还有就是我得挑出<code>{{attr1}}</code>来， 它是一个文本节点，并且身上长有<code>{{}}</code>特征的，那没问题，找到后我就<code>vm[attr1]</code>替换掉，完美。  <code>v-model</code>这种，它是在节点属性上，如果是节点的话，我看属性<code>node.attributes</code>有没有符合要求的,  属性里挑出来<code>v-model=attr1</code>， 找到后我就<code>node.value= vm[attr1]</code> 赋进<code>input</code>元素。</p></li>
<li><p>模版上出来值了，可是<code>input</code>输入的时候，我这里的数据要跟着变啊，这个得让哥们<code>c</code>加一个监听<code>input</code>事件，拿到值<code>value</code>后，我就直接赋值<code>vm[attr1]=value</code>,  这个时候，我哥们<code>o</code>那边能观察到被设值了</p></li>
<li><p>问题是，我改变了<code>attr1</code>的值，页面要跟着变啊，怎么破？ 改变的时候，哥们<code>o</code>是知道的，让他通知更新？ 他咋知道给谁，这个谁就是<code>{{attr1}}</code>，这货就是订阅者，那页面不得很多订阅者啊。这个订阅者让哥们<code>w</code>搞定。  我得收集这些订阅者<code>watcher</code>,  得捋一捋，一个属性<code>attr1</code>可能会有多个订阅者<code>w</code>， 像<code>&lt;span&gt;{{attr1}}&lt;/span&gt;</code>、 <code>&lt;p&gt;{{attr1}}&lt;/p&gt;</code>都用到了对吧，那我属性一改变时，全部订阅者都得跟着更新。 这样吧， 给他们整一个收集器, 收集器让哥们<code>D</code>做，每一个属性， 都会有一个属于自己的收集器<code>D</code>，我就知道都有谁用了我的属性。 当属性改变时，我让当前这个属性的收集器去通知它下面的所有订阅者， 完美。</p></li>
<li><p>哥们<code>D</code>收集器： 啥意思？</p></li>
<li><p>哥们<code>w</code>订阅者： 你就直接告我让我干啥吧</p></li>
<li><p>订阅者<code>w</code> ， 我需要你在适当的时候可以更新节点数据。 收集器<code>D</code>，你负责收集并通知</p></li>
<li><p>哥们<code>w</code>： 啥时候要用到我？</p></li>
<li><p>在哥们<code>c</code>编译的时候，找对相应节点赋值那里就要创建一个订阅者<code>w</code></p></li>
<li><pre><code class="hljs css language-js">compileText: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node, exp</span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  ...
  new Watcher(<span class="hljs-keyword">this</span>.vm, exp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    self.updateText(node, value);
  });
}
compileModel: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, vm, exp, dir</span>) </span>{
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  ...
  new Watcher(<span class="hljs-keyword">this</span>.vm, exp, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    self.modelUpdater(node, value);
  });
  ...
}
</code></pre></li>
<li><p>哥们<code>D</code>收集器： 那我什么时候去收集？</p></li>
<li><p>嗯？ 但凡有一个订阅者<code>w</code>被创建， 你就要去收集它， 哥们<code>o</code>它知道哪里做收集动作</p></li>
<li><p>哥们<code>o</code>:  不知道怎么写？怎么保证只收集一次，不会重复收集</p></li>
<li><p>创建订阅者<code>w</code>的时候就能做手脚,  创建的时候，给收集器挂在一个当前的订阅者<code>w</code>， 然后有意去访问，触发哥们<code>o</code>里的<code>get</code>， 收集完后，关闭。</p></li>
<li><p>哥们<code>w</code>： 明白，就这样：</p></li>
<li><pre><code class="hljs css language-js">Dep.target = <span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 缓存自己</span>
<span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.vm.data[<span class="hljs-keyword">this</span>.exp]  <span class="hljs-comment">// 强制执行监听器里的get函数</span>
Dep.target = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 释放自己</span>
</code></pre></li>
<li><p>哥们<code>o</code>： 那我就这样配合你</p>
<pre><code class="hljs css language-js">defineReactive: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, key, val</span>) </span>{
  <span class="hljs-comment">// 每一属性，都有一个收集器</span>
  <span class="hljs-keyword">var</span> dep = <span class="hljs-keyword">new</span> Dep();
  <span class="hljs-built_in">Object</span>.defineProperty(data, key, {
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getter</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (Dep.target) {
        <span class="hljs-comment">// 收集的动作</span>
        dep.addSub(Dep.target);
      }
      <span class="hljs-keyword">return</span> val;
    },
    <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setter</span> (<span class="hljs-params">newVal</span>) </span>{
      <span class="hljs-keyword">if</span> (newVal === val) {
        <span class="hljs-keyword">return</span>;
      }
      val = newVal;
      <span class="hljs-comment">// 该收集器通知所有订阅者更新</span>
      dep.notify();
    }
  });
}
</code></pre></li>
<li><p>再捋一捋，<code>data</code>下的属性<code>attr1</code>，一开始的时候，编译模版，然后看有多少订阅者<code>w</code>， 全给他创建，然后创建的同时，每一个订阅者<code>w</code>都会被收集到属于<code>attr1</code>的收集器中， 然后如果<code>input</code>外部输入，那我在事件里去调用<code>vm[attr1] = value</code>， 就是触发<code>set</code>,  对应的收集器就发通知，全部订阅者就更新，页面上看到全部订阅者都同步了。 然后如果直接修改<code>vm[attr1]</code>也是一样的逻辑，嗯，说得通</p></li>
<li><p>有个问题，就是现在只是观察<code>data</code>， 如果<code>data</code>下的一个属性上一个对象，那也要被观察，这就要递归观察了</p>
<pre><code class="hljs css language-js">defineReactive: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, key, val</span>) </span>{
  <span class="hljs-keyword">var</span> childObj = observe(val);
  ...
}
</code></pre>
<p><a href="https://github.com/canfoo/self-vue/blob/master/v3/js/index.js">代码</a></p></li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/10/08/vuex">实现一个简单的vuex</a></h1><p class="post-meta">October 8, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="分析"></a><a href="#分析" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分析</h3>
<ul>
<li><code>vuex</code>导出一个<code>install</code>方法（用来安装插件到vue），一个<code>Store</code>方法(用来实例一个store),</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {Store, install}
</code></pre>
<ul>
<li><code>store</code>实例有哪些参数</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">new</span> Vuex.Store({
  <span class="hljs-attr">state</span>: {

  },
  <span class="hljs-attr">mutations</span>: {

  },
  <span class="hljs-attr">actions</span>: {

  }
})
</code></pre>
<ul>
<li><code>install</code>方法，把实例化后的<code>store</code>挂在到<code>vue</code>实例的原型对象下</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">install</span>(<span class="hljs-params">_Vue</span>) </span>{
    Vue = _Vue;

    <span class="hljs-comment">// 混入store</span>
    Vue.mixin({
        beforeCreate() {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.store) {
                Vue.prototype.$store = <span class="hljs-keyword">this</span>.$options.store;
            }
        }
    })
}
</code></pre>
<ul>
<li><code>store</code>的数据，通过一个响应对象来管理，这里利用了<code>vue</code>本身的响应能力</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span> </span>{
    <span class="hljs-keyword">constructor</span>(options = {}) {
        <span class="hljs-comment">// 响应化处理</span>
        <span class="hljs-keyword">this</span>.state = <span class="hljs-keyword">new</span> Vue({
            <span class="hljs-attr">data</span>: options.state            
        })
        <span class="hljs-keyword">this</span>.mutations = options.mutations || {};
        <span class="hljs-keyword">this</span>.actions = options.actions || {};
    }
}
</code></pre>
<ul>
<li>改变状态, 实现<code>commit</code>方法</li>
</ul>
<p>调用</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">"increment"</span>)
</code></pre>
<p>定义</p>
<pre><code class="hljs css language-javascript">increment(state) {
  state.count += <span class="hljs-number">1</span>;
}
</code></pre>
<p><code>commit</code></p>
<pre><code class="hljs css language-javascript">...
<span class="hljs-comment">// type是mutations中的函数名</span>
commit = <span class="hljs-function">(<span class="hljs-params">type, arg</span>) =&gt;</span> {
  <span class="hljs-keyword">this</span>.mutations[type](<span class="hljs-keyword">this</span>.state, arg)
}
...
</code></pre>
<ul>
<li>实现<code>dispatch</code>方法</li>
</ul>
<p>定义</p>
<pre><code class="hljs css language-javascript">actions: {
  increment({ getters, commit }) {
    <span class="hljs-comment">// 添加业务逻辑</span>
    <span class="hljs-keyword">if</span> (getters.left &gt; <span class="hljs-number">0</span>) {
      commit(<span class="hljs-string">"increment"</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">// 返回结果</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">// 返回结果</span>
  },
  asyncIncrement({ dispatch }) {
    <span class="hljs-comment">// 异步逻辑返回Promise</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-comment">// 复用其他action</span>
        resolve(dispatch(<span class="hljs-string">"increment"</span>));
      }, <span class="hljs-number">1000</span>);
    });
  },
}
</code></pre>
<p>使用</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">"increment"</span>)
<span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">"asyncIncrement"</span>).then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {        
  <span class="hljs-keyword">if</span> (!result) {
    alert(<span class="hljs-string">"投掷失败！没货啦"</span>);
  }
});
</code></pre>
<p>实现</p>
<pre><code class="hljs css language-javascript">dispatch(type, arg) {
    <span class="hljs-keyword">this</span>.actions[type]({
        <span class="hljs-attr">commit</span>: <span class="hljs-keyword">this</span>.commit,
        <span class="hljs-attr">state</span>: <span class="hljs-keyword">this</span>.state
    }, arg)
}
</code></pre>
<ul>
<li>实现<code>Getter</code></li>
</ul>
<p>在组件中可以这样使用<code>getters</code></p>
<pre><code class="hljs css language-javascript">store.getters.jobs
</code></pre>
<p>定义</p>
<pre><code class="hljs css language-javascript">state: {
  <span class="hljs-attr">jobs</span>: [
    { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">'...'</span>, <span class="hljs-attr">good</span>: <span class="hljs-literal">true</span> },
    { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">'...'</span>, <span class="hljs-attr">good</span>: <span class="hljs-literal">false</span> }
  ]
},
<span class="hljs-attr">getters</span>: {
  <span class="hljs-attr">jobs</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> state.jobs.filter(<span class="hljs-function"><span class="hljs-params">job</span> =&gt;</span> job.good)
  }
}
</code></pre>
<p>实现</p>
<pre><code class="hljs css language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span></span>{
  <span class="hljs-keyword">constructor</span>(options = {}) {
    options.getters &amp;&amp; <span class="hljs-keyword">this</span>.handleGetters(options.getters)
  }
  handleGetters(getters) {
    <span class="hljs-keyword">this</span>.getters = {}
    <span class="hljs-built_in">Object</span>.keys(getters).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>.getters, key, {
        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-keyword">return</span> getters[key](<span class="hljs-keyword">this</span>.state)
        }
      })
    })
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="源码"></a><a href="#源码" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码</h3>
<ul>
<li>源码里是怎么把<code>store</code>实例挂载到每一个<code>vue</code>组件实例下<code>$store</code>属性的？</li>
</ul>
<p>初始化的时候，找到<code>store</code>实例，分2种情况，如果当前是根组件，如果不是根组件。</p>
<p>判断是不是根组件，通过<code>this.$options.store</code>判断，有值意味着根组件，否则非根组件</p>
<p>根组件，直接赋值<code>this.$store = this.$options.store</code></p>
<p>非根组件，为了让每一个组件拿到的<code>$store</code>实例都是同一份内存地址的，使用<code>this.$options.parent</code>访问</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">if</span> (options.parent &amp;&amp; options.parent.$store) {
  <span class="hljs-keyword">this</span>.$store = options.parent.$store
}
</code></pre>
<ul>
<li><code>module</code>源码处理</li>
</ul>
<pre><code class="hljs css language-javascript">modules: {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">state</span>: {
      <span class="hljs-attr">test</span>: <span class="hljs-number">1</span>
    },
    <span class="hljs-attr">mutations</span>: {

    }
  }
}
</code></pre>
<p>使用的时候，访问<code>a</code>模块的<code>state</code></p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">this</span>.$store.state.a.count
</code></pre>
<ol>
<li>要把当前模块<code>a</code>的<code>state</code>挂载到父<code>state</code>下</li>
</ol>
<p>使用了<code>Vue.set</code>, 例如，<code>Vue.set({}, 'a', {test: 1})</code></p>
<p>此时父<code>state</code>刚好是根<code>state</code>, 这样可以使得<code>vue</code>实例监听到<code>属性</code>的改动</p>
<ol start="2">
<li>命名空间<code>a</code>好找，通过一个数组，当前命名空间就是最后一项的值。 问题是怎么把父<code>state</code>找出来</li>
</ol>
<p>分情况，如果只有一个层级的模块，那它的父<code>state</code>就是根<code>state</code>, 即把当前模块从数组中干掉, 那剩下的判断<code>path.slice(0, -1)</code> =&gt; []</p>
<p>如果剩下的不是空，即有长度，怎么取父模块<code>state</code>， 我们假设<code>a</code>模块下加一个<code>b</code>模块</p>
<pre><code class="hljs css language-javascript">modules: {
  <span class="hljs-attr">a</span>: {
    <span class="hljs-attr">state</span>: {
      <span class="hljs-attr">test</span>: <span class="hljs-number">1</span>
    },
    <span class="hljs-attr">mutations</span>: {

    },
    <span class="hljs-attr">modules</span>: {
      <span class="hljs-attr">b</span>: {

      }
    }
  }
}
</code></pre>
<p>这个时候，我在注册<code>b</code>模块的时候，拿到的父<code>state</code>应该是什么， 应该是<code>state.a</code></p>
<p>这里使用<code>reduce</code>处理</p>
<pre><code class="hljs css language-javascript">path.reduce(<span class="hljs-function">(<span class="hljs-params">state, key</span>) =&gt;</span> state[key], state)
</code></pre>
<p>所以最后我们看到，获取父<code>state</code>的代码如下：</p>
<pre><code class="hljs css language-javascript">getNestedState(rootState, path.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>))
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNestedState</span> (<span class="hljs-params">state, path</span>) </span>{
  <span class="hljs-keyword">return</span> path.length
    ? path.reduce(<span class="hljs-function">(<span class="hljs-params">state, key</span>) =&gt;</span> state[key], state)
    : state
}
</code></pre>
<p><code>Vue.set</code>的代码就是如下：</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>))
<span class="hljs-keyword">const</span> moduleName = path[path.length - <span class="hljs-number">1</span>]
store._withCommit(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  Vue.set(parentState, moduleName, state || {})
})
</code></pre>
<ul>
<li>递归注册模块</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">installModule</span>(<span class="hljs-params">...</span>) </span>{
  <span class="hljs-keyword">if</span> (modules) {
    <span class="hljs-built_in">Object</span>.keys(modules).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
      installModule(store, rootState, path.concat(key), modules[key], hot)
    })
  }
}
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/09/30/vue-router">实现一个简单的vue-router</a></h1><p class="post-meta">September 30, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="怎么用"></a><a href="#怎么用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>怎么用</h3>
<p><code>router.js</code></p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">'./views/home'</span>


<span class="hljs-comment">// vue-router 插件形式安装</span>
Vue.use(VueRouter)

<span class="hljs-comment">// vue-router 实例</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter({
    <span class="hljs-attr">routes</span>: [
        {
            <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">'home'</span>,
            <span class="hljs-attr">component</span>: Home
        }
    ]
})
</code></pre>
<p><code>main.js</code></p>
<pre><code class="hljs css language-javascript">import router from './router
// 把vue-router实例挂载到vue实例上
new Vue({
  router
  ...
}).$mount('#app')
</code></pre>
<ul>
<li><p><code>Vue.use</code>做了什么</p>
<ul>
<li><code>install</code>注册
<ul>
<li><code>$router</code>挂在到vue的每一个实例里去</li>
<li>注册组件</li>
</ul></li>
</ul></li>
<li><p>为什么要传<code>router</code>给<code>new Vue</code>实例</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="实现"></a><a href="#实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现</h3>
<p><code>vue-router.js</code></p>
<ul>
<li><p>肯定有一个类<code>VueRouter</code></p></li>
<li><p>肯定有一个<code>install</code>方法</p></li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueRouter</span> </span>{
    <span class="hljs-keyword">constructor</span>() {

    }
}

VueRouter.install = funciton(_Vue) {

}
</code></pre>
<ul>
<li><code>install</code>方法传入<code>Vue</code>， 保存到模块里，方便使用</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> Vue
VueRouter.install = funciton(_Vue) {
    Vue = _Vue
}
</code></pre>
<ul>
<li>为了让每一个<code>vue</code>组件实例，都能通过<code>this.$router</code>访问，使用混入</li>
</ul>
<pre><code class="hljs css language-javascript">VueRouter.install = funciton(_Vue) {
    Vue = _Vue
    VUe.mixin({
        beforeCreate() {
            <span class="hljs-comment">// $options  https://cn.vuejs.org/v2/api/#vm-options</span>
            <span class="hljs-comment">// 根组件执行一次</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.router) {
                <span class="hljs-comment">// 这里都this 指向 Vue实例</span>
                Vue.prototype.$router = <span class="hljs-keyword">this</span>.$options.router
                <span class="hljs-comment">// 初始化</span>
                <span class="hljs-keyword">this</span>.$options.router.init()
            }
        }
    })
}
</code></pre>
<ul>
<li>处理传入的参数</li>
</ul>
<p>使用</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">new</span> VueRouter({
    <span class="hljs-attr">routes</span>: [
        {
            <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">'home'</span>,
            <span class="hljs-attr">component</span>: Home
        }
    ]
})
</code></pre>
<p>实现</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VueRouter</span> </span>{
    <span class="hljs-keyword">constructor</span>(options) {
        <span class="hljs-comment">// $options下有routes</span>
        <span class="hljs-keyword">this</span>.$options = options
    }

    init () {
        <span class="hljs-comment">// 这里做什么</span>
    }
}
</code></pre>
<ul>
<li><p>单页面路由实现2种方案，一个是<code>hash</code>改变，页面不更新，切换组件， 一种是<code>HTML5</code>的<code>history</code>方式</p></li>
<li><p>这里通过<code>hash</code>方式来实现, 首先要监听<code>hashchange</code>事件</p></li>
</ul>
<pre><code class="hljs css language-javascript">init() {
    <span class="hljs-comment">// 1. 事件监听</span>
    <span class="hljs-keyword">this</span>.bindEvents();
}

bindEvents() {
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'hashchange'</span>, <span class="hljs-keyword">this</span>.onHashChange.bind(<span class="hljs-keyword">this</span>))
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'load'</span>, <span class="hljs-keyword">this</span>.onHashChange.bind(<span class="hljs-keyword">this</span>))
}

onHashChange() {
 <span class="hljs-comment">// 当监听到hash改变的时候，做什么</span>
 <span class="hljs-comment">// 想象一下。。。</span>
}
</code></pre>
<ul>
<li><code>hash</code>改变了，意味着我的路由也跟着变，当前<code>hash</code>值对应当前路由，对应当前组件，我们要建立这种关系，当前的<code>hash</code>值对应组件的映射关系，说白了，手上有<code>hash</code>值，我要拿到对应的组件配置</li>
</ul>
<pre><code class="hljs css language-javascript">onHashChange() {
    <span class="hljs-comment">// #/index</span>
    <span class="hljs-keyword">this</span>.current = <span class="hljs-built_in">window</span>.location.hash.slice(<span class="hljs-number">1</span>) || <span class="hljs-string">'/'</span>
}
</code></pre>
<ul>
<li>这里应用了vue本身data中的响应式特点, 即<code>this.app.current</code></li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">this</span>.app = <span class="hljs-keyword">new</span> Vue({
    <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">current</span>: <span class="hljs-string">'/'</span>
    }
})
</code></pre>
<ul>
<li>路由映射，说白了，就是一个对象，<code>key:value</code>对应关系</li>
</ul>
<pre><code class="hljs css language-javascript">init() {
    <span class="hljs-keyword">this</span>.createRouteMap();
}

createRouteMap(){
    <span class="hljs-keyword">this</span>.$options.routes.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
        <span class="hljs-keyword">this</span>.routeMap[item.path] = item;
    })
}
</code></pre>
<ul>
<li><code>router-link</code>、<code>router-view</code>组件创建</li>
</ul>
<pre><code class="hljs css language-javascript">initComponent(){
    <span class="hljs-comment">// router-link</span>
    <span class="hljs-comment">// &lt;router-link to="/"&gt;abc&lt;/router-link&gt;</span>
    Vue.component(<span class="hljs-string">'router-link'</span>, {
        <span class="hljs-attr">props</span>: {
            <span class="hljs-attr">to</span>: <span class="hljs-built_in">String</span>
        },
        render(h) {
            <span class="hljs-comment">// h(tag, data, children)</span>
            <span class="hljs-comment">// this是组件实例</span>
            <span class="hljs-keyword">return</span> h(<span class="hljs-string">'a'</span>, {<span class="hljs-attr">attrs</span>: {<span class="hljs-attr">href</span>: <span class="hljs-string">'#'</span> +  <span class="hljs-keyword">this</span>.to}}, [<span class="hljs-keyword">this</span>.$slots.default])
        }
    })
    <span class="hljs-comment">// router-view</span>
    Vue.component(<span class="hljs-string">'router-view'</span>, {
        <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> {
            <span class="hljs-comment">// 拿出要渲染的组件</span>
            <span class="hljs-comment">// this希望是Router实例</span>
            <span class="hljs-keyword">const</span> component = <span class="hljs-keyword">this</span>.routeMap[<span class="hljs-keyword">this</span>.app.current].component;
            <span class="hljs-keyword">return</span> h(component)
        }
    })
}
</code></pre>
<ul>
<li>这里要注意一下， <code>router-view</code>是全局组件，<code>vue</code>实例的data属性, 在<code>router-view</code>组件的<code>render</code>中使用，一样，如果属性发生变化, 会重新调用<code>render</code>渲染</li>
</ul>
<ul>
<li><p>单页面应用，将路径跟组件映射起来， 这就是单页面路由模块的本质</p></li>
<li><p>整个应用只有一个完整的页面，更新视图不重新请求页面</p></li>
<li><p><code>hash</code>是页面<code>URL</code>的锚点，代表在页面中的位置，改变<code>#</code>后面的值，浏览器回滚动到指定的位置</p></li>
<li><p><code>history</code>模式利用<code>history.pushState</code>完成<code>URL</code>跳转不重新加载页面， 这种模式<code>url</code>后没有<code>#</code>，不那么丑。 有个问题，例如访问<code>oursite.com/user/id</code>， 上线后会返回<code>404</code>，后台要配置一下，如果<code>URL</code>匹配不到任何静态资源，应该返回同一个<code>index.html</code></p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="源码那点事"></a><a href="#源码那点事" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>源码那点事</h3>
<ol>
<li>如果环境已经挂载了<code>vue</code>, 就自动去使用<code>vue-router</code>。 这个逻辑的判断如下</li>
</ol>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">if</span> (inBrowser &amp;&amp; <span class="hljs-built_in">window</span>.Vue) {
  <span class="hljs-built_in">window</span>.Vue.use(VueRouter)
}
</code></pre>
<ol start="2">
<li>注意到源码的<code>install.js</code>文件，除了暴露<code>install</code>方法， 还暴露了<code>_Vue</code>， 这是为啥？ 这里有一个需求，就是我不想把<code>vue</code>通过<code>import Vue from 'vue'</code>打包到我的插件里，但是我又想使用，怎么办？ 在<code>install</code>方法执行后，通过传入的<code>Vue</code>，我存起来，存到我的<code>install.js</code>模块中，所以只有在调用了<code>install</code>之后才能使用暴露出去的<code>_Vue</code></li>
</ol>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> _Vue
</code></pre>
<ol start="3">
<li>怎么避免插件重复执行<code>install</code>安装，源码里是怎么写的？</li>
</ol>
<p>给<code>install</code>函数挂一个属性<code>installed</code>，同时仍然是同一个<code>vue</code>实例，就认为已经安装了，没必要再安装一次</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">if</span> (install.installed &amp;&amp; _Vue === Vue) <span class="hljs-keyword">return</span>
install.installed = <span class="hljs-literal">true</span>

_Vue = Vue
</code></pre>
<ol start="4">
<li>有意思的是，类似这种插件的思路，我搞一个<code>vue-router</code>插件类， 你通过你的插件安装机制调用<code>install</code>方法， 调用的同时，你得把我这个插件的实例传进来给到我，我在里面拿到实例，进行调用自己的<code>init</code>方法完成初始化。 更有意思的是，我可以通过混入<code>mixin</code>, 把插件实例挂载到你<code>vue</code>组件实例里</li>
</ol>
<ol start="5">
<li>路由更新时，要通知<code>router-view</code>去更新组件，源码这里使用<code>vue</code>工具方法，定义一个响应式对象，就是响应式路由对象<code>_route</code></li>
</ol>
<pre><code class="hljs css language-javascript"> Vue.util.defineReactive(<span class="hljs-keyword">this</span>, <span class="hljs-string">'_route'</span>, <span class="hljs-keyword">this</span>._router.history.current)
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/09/16/tree2">二叉树</a></h1><p class="post-meta">September 16, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="二叉树"></a><a href="#二叉树" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>二叉树</h3>
<ul>
<li>一个根节点</li>
<li>每个节点最多只有2个子节点，分别为左节点、右节点</li>
</ul>
<blockquote>
<p>二叉搜索树</p>
</blockquote>
<ul>
<li>左节点比父节点值小</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="实现类"></a><a href="#实现类" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现类</h3>
<ul>
<li>创建一个二分树类</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bst</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    
  }
}
</code></pre>
<ul>
<li>创建一个节点类</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{
  <span class="hljs-keyword">constructor</span>(key) {
    <span class="hljs-keyword">this</span>.key = key
    <span class="hljs-keyword">this</span>.left = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">this</span>.right = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">this</span>.root = <span class="hljs-literal">null</span>
  }
}
</code></pre>
<ul>
<li><p>往<code>Bst</code>添加值为<code>8</code>的节点</p></li>
<li><p>继续<code>Bst</code>添加值为<code>10</code>的节点</p></li>
<li><p>继续<code>Bst</code>添加值为<code>6</code>的节点</p></li>
<li><p>最后结果应该： <code>8(6, 10)</code></p></li>
<li><p>实现</p></li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bst</span> </span>{
  ...
  insert(key){
    <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">new</span> Node(key)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root) {
      <span class="hljs-comment">// 新建一个函数，因为要递归处理</span>
      <span class="hljs-keyword">this</span>._insertNode(<span class="hljs-keyword">this</span>.root, node)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.root = node
    }
  }
  _insertNode(node, newNode) {
    <span class="hljs-keyword">if</span> (newNode.key &lt; node.key) {
      <span class="hljs-comment">// 如果值没父节点的大， 靠左</span>
      <span class="hljs-keyword">if</span> (!node.left) {
        <span class="hljs-comment">// 如果左节点还没</span>
        node.left = newNode
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 如果左节点有了， 把左节点当作新的父节点，递归判断插入</span>
        <span class="hljs-keyword">this</span>._insertNode(node.left, newNode)
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 如果值比父节点的大， 靠右</span>
      <span class="hljs-keyword">if</span> (!node.right) {
        <span class="hljs-comment">// 如果右节点还没</span>
        node.right = newNode
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 如果右节点有了， 把右节点当作新的父节点，递归判断插入</span>
        <span class="hljs-keyword">this</span>._insertNode(node.right, newNode)
      }
    }
  }
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="访问树大所有节点-遍历"></a><a href="#访问树大所有节点-遍历" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>访问树大所有节点 - 遍历</h4>
<p><code>中序</code>、<code>先序</code>、<code>后序</code></p>
<pre><code class="hljs css language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bst</span> </span>{
  ...
  <span class="hljs-comment">// 中序</span>
  inSort(cb) {
    <span class="hljs-keyword">const</span> sort = <span class="hljs-function">(<span class="hljs-params">node, cb</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (node) {
        sort(node.left, cb)
        cb(node.key)
        sort(node.right, cb)
      }
    }
    sort(<span class="hljs-keyword">this</span>.root, cb)
  }
  <span class="hljs-comment">// 先序</span>
  preSort(cb) {
    <span class="hljs-keyword">const</span> sort = <span class="hljs-function">(<span class="hljs-params">node, cb</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (node) {
        cb(node.key)
        sort(node.left, cb)
        sort(node.right, cb)
      }
    }
    sort(<span class="hljs-keyword">this</span>.root, cb)
  }
  <span class="hljs-comment">// 后序</span>
  postinSort(cb) {
    <span class="hljs-keyword">const</span> sort = <span class="hljs-function">(<span class="hljs-params">node, cb</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (node) {
        sort(node.left, cb)
        sort(node.right, cb)
        cb(node.key)
      }
    }
    sort(<span class="hljs-keyword">this</span>.root, cb)
  }
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="二叉搜索树中的值-搜索"></a><a href="#二叉搜索树中的值-搜索" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>二叉搜索树中的值，搜索</h4>
<blockquote>
<p>找出最小值</p>
</blockquote>
<p>左侧小，一直靠左一直小， 只要还有左侧的节点，就还有更小的值</p>
<pre><code class="hljs css language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bst</span> </span>{
  ...
  min() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root) {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.root
      <span class="hljs-keyword">while</span> (node &amp;&amp; node.left !== <span class="hljs-literal">null</span>) {
        node = node.left
      }
      <span class="hljs-keyword">return</span> node.key
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }
  }
}
</code></pre>
<blockquote>
<p>找出最大值</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bst</span> </span>{
  ...
  max() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.root) {
      <span class="hljs-keyword">let</span> node = <span class="hljs-keyword">this</span>.root
      <span class="hljs-keyword">while</span> (node &amp;&amp; node.right !== <span class="hljs-literal">null</span>) {
        node = node.right
      }
      <span class="hljs-keyword">return</span> node.key
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }
  }
}
</code></pre>
<blockquote>
<p>判断特定的值在二叉树中是否存在</p>
</blockquote>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/09/08/linklist">实现链表并应用</a></h1><p class="post-meta">September 8, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="定义"></a><a href="#定义" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定义</h3>
<ul>
<li><p>猴子捞月</p></li>
<li><p>节点组成</p>
<ul>
<li>节点分为： 数据 ； 下一个的指针</li>
</ul></li>
<li><p>有首节点、尾节点</p></li>
</ul>
<blockquote>
<p>分析</p>
</blockquote>
<pre><code class="hljs"><span class="hljs-type">A</span>(  
    <span class="hljs-class"><span class="hljs-keyword">data</span>,</span>
    next =&gt; <span class="hljs-type">B</span>   
)

<span class="hljs-type">B</span>(  
    <span class="hljs-class"><span class="hljs-keyword">data</span>,</span>
    next =&gt; <span class="hljs-type">C</span>
)

<span class="hljs-type">C</span>(  
    <span class="hljs-class"><span class="hljs-keyword">data</span>,</span>
    next =&gt; <span class="hljs-type">D</span>
)

<span class="hljs-type">D</span>(  
    <span class="hljs-class"><span class="hljs-keyword">data</span>,</span>
    next =&gt; <span class="hljs-type">E</span>
)

</code></pre>
<h4><a class="anchor" aria-hidden="true" id="添加元素a"></a><a href="#添加元素a" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>添加元素A</h4>
<ul>
<li><p>如果一个都还没有：
头节点 = 新添加的A
尾节点 = 头节点
链表长度+1</p></li>
<li><p>如果已经有了
尾节点.next = A
尾节点 = A
链表长度+1</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="在b节点处插入m节点"></a><a href="#在b节点处插入m节点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在B节点处插入M节点</h4>
<ul>
<li><p>如果B节点是最后一个，相当于往后往后添加一个M，使用上面的方法</p></li>
<li><p>如果B节点是第一个，即头部追加一个M, 这个时候M.next = B; head = M</p></li>
<li><p>如果B节点位置在首尾部之间： 知道B索引为1， 我要拿到B节点，然后B.next节点 = M， 同时M.next应该是原来的B.next，这样才能衔接上，所以要把原来B.next变量存储一下</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="移除指定c节点"></a><a href="#移除指定c节点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>移除指定C节点</h4>
<ul>
<li><p>位置值index</p></li>
<li><p>判断index是否在有效位置区间</p></li>
<li><p>找到C节点，找到C节点的上一个节点B</p></li>
<li><p>B.next 应该等于 C.next</p></li>
<li><p>C.next 应该释放掉 = null</p></li>
<li><p>c.data 删掉</p></li>
<li><p>注意，如果删除的是尾节点D, 需要把tail更改为C</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="返回制定位置的节点数据"></a><a href="#返回制定位置的节点数据" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>返回制定位置的节点数据</h4>
<ul>
<li><p>知道位置index</p></li>
<li><p>从0开始排查</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="根据节点数据data-返回位置"></a><a href="#根据节点数据data-返回位置" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>根据节点数据data, 返回位置</h4>
<ul>
<li><p>从头节点开始排查</p></li>
<li><p>直到data === data, 拿到位置值返回</p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="清空链表"></a><a href="#清空链表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>清空链表</h4>
<ul>
<li>头节点、尾节点 = null</li>
<li>长度 = 0</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="输出打印链表"></a><a href="#输出打印链表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>输出打印链表</h4>
<ul>
<li>每一个节点的data, 拼接打印出来</li>
</ul>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkList</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-comment">// 定义节点</span>
    <span class="hljs-keyword">var</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
        <span class="hljs-keyword">this</span>.data = data;
        <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> length = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 长度</span>
    <span class="hljs-keyword">var</span> head = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 头节点</span>
    <span class="hljs-keyword">var</span> tail = <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 尾节点</span>

    <span class="hljs-comment">// 添加一个新元素</span>
    <span class="hljs-keyword">this</span>.append = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
        <span class="hljs-comment">// 创建新节点</span>
        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(data);
        <span class="hljs-comment">// 如果是空链表</span>
        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>){
            head = node;
            tail = head;
        }<span class="hljs-keyword">else</span>{
            tail.next = node;       <span class="hljs-comment">// 尾节点指向新创建的节点</span>
            tail = node;            <span class="hljs-comment">// tail指向链表的最后一个节点</span>
        }
        length += <span class="hljs-number">1</span>;                <span class="hljs-comment">// 长度加1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };

    <span class="hljs-comment">// 返回链表大小</span>
    <span class="hljs-keyword">this</span>.length = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> length;
    };

    <span class="hljs-comment">// 在指定位置插入新的元素</span>
    <span class="hljs-keyword">this</span>.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, data</span>)</span>{
        <span class="hljs-keyword">if</span>(index == length){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.append(data);
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index &gt; length || index &lt; <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">var</span> new_node = <span class="hljs-keyword">new</span> Node(data);
            <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>){
                new_node.next= head;
                head = new_node;
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">var</span> insert_index = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">var</span> curr_node = head;
                <span class="hljs-comment">// 找到应该插入的位置</span>
                <span class="hljs-keyword">while</span>(insert_index &lt; index){
                    curr_node = curr_node.next;
                    insert_index += <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">var</span> next_node = curr_node.next;
                curr_node.next = new_node;
                new_node.next = next_node;
            }
            length += <span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    };

    <span class="hljs-comment">// 删除指定位置的节点</span>
    <span class="hljs-keyword">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>)</span>{
        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= length){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">var</span> del_node = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>){
                <span class="hljs-comment">// head指向下一个节点</span>
                del_node = head;
                head = head.next;
            }<span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">var</span> del_index = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">var</span> pre_node = <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">var</span> curr_node = head;
                <span class="hljs-keyword">while</span>(del_index &lt; index){
                    del_index += <span class="hljs-number">1</span>;
                    pre_node = curr_node;
                    curr_node =curr_node.next;
                }
                del_node = curr_node;
                pre_node.next = curr_node.next;
                <span class="hljs-comment">// 如果删除的是尾节点</span>
                <span class="hljs-keyword">if</span>(curr_node.next==<span class="hljs-literal">null</span>){
                    tail = pre_node;
                }
            }
            length -= <span class="hljs-number">1</span>;
            del_node.next = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">return</span> del_node.data;
        }
    };

    <span class="hljs-comment">// 删除尾节点</span>
    <span class="hljs-keyword">this</span>.remove_tail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.remove(length<span class="hljs-number">-1</span>);
    };

    <span class="hljs-comment">// 删除头节点</span>
    <span class="hljs-keyword">this</span>.remove_head = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.remove(<span class="hljs-number">0</span>);
    };

    <span class="hljs-comment">// 返回指定位置节点的值</span>
    <span class="hljs-keyword">this</span>.get = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>)</span>{
        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= length){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">var</span> node_index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> curr_node = head;
        <span class="hljs-keyword">while</span>(node_index &lt; index){
            node_index += <span class="hljs-number">1</span>;
            curr_node = curr_node.next;
        }
        <span class="hljs-keyword">return</span> curr_node.data;
    };

    <span class="hljs-comment">// 返回链表头节点的值</span>
    <span class="hljs-keyword">this</span>.head = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(<span class="hljs-number">0</span>);
    }

    <span class="hljs-comment">// 返回链表尾节点的值</span>
    <span class="hljs-keyword">this</span>.tail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(length<span class="hljs-number">-1</span>);
    }

    <span class="hljs-comment">// 返回指定元素的索引,如果没有,返回-1</span>
    <span class="hljs-comment">// 有多个相同元素,返回第一个</span>
    <span class="hljs-keyword">this</span>.indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
        <span class="hljs-keyword">var</span> index = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">var</span> curr_node = head;
        <span class="hljs-keyword">while</span>(curr_node){
            index += <span class="hljs-number">1</span>
            <span class="hljs-keyword">if</span>(curr_node.data == data){
                <span class="hljs-keyword">return</span> index;
            }<span class="hljs-keyword">else</span>{
                curr_node = curr_node.next;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    };

    <span class="hljs-comment">// 输出链表</span>
    <span class="hljs-keyword">this</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">var</span> curr_node = head;
        <span class="hljs-keyword">var</span> str_link = <span class="hljs-string">""</span>
        <span class="hljs-keyword">while</span>(curr_node){

            str_link += curr_node.data.toString() + <span class="hljs-string">" -&gt;"</span>;
            curr_node = curr_node.next;
        }
        str_link += <span class="hljs-string">"null"</span>;
        <span class="hljs-built_in">console</span>.log(str_link);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"长度为"</span>+ length.toString());
    };

    <span class="hljs-comment">// isEmpty</span>
    <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> length == <span class="hljs-number">0</span>;
    };

    <span class="hljs-comment">// 清空链表</span>
    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        head = <span class="hljs-literal">null</span>;
        tail = <span class="hljs-literal">null</span>;
        length = <span class="hljs-number">0</span>;
    };

};

exports.LinkList = LinkList;

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="使用链表实现栈"></a><a href="#使用链表实现栈" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用链表实现栈</h3>
<pre><code class="hljs css language-javascript">LinkList = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./mylinklist"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> linklist = <span class="hljs-keyword">new</span> LinkList.LinkList();

    <span class="hljs-comment">// 从栈顶添加元素</span>
    <span class="hljs-keyword">this</span>.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{
        linklist.append(item);
    };

    <span class="hljs-comment">// 弹出栈顶元素</span>
    <span class="hljs-keyword">this</span>.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.remove_tail();
    };

    <span class="hljs-comment">// 返回栈顶元素</span>
    <span class="hljs-keyword">this</span>.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.tail();
    };

    <span class="hljs-comment">// 返回栈的大小</span>
    <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.length();
    };

    <span class="hljs-comment">// 判断是否为空</span>
    <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.isEmpty();
    };

    <span class="hljs-comment">// 清空栈</span>
    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        linklist.clear()
    };
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="使用链表实现队列"></a><a href="#使用链表实现队列" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用链表实现队列</h3>
<pre><code class="hljs css language-javascript">
LinkList = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./mylinklist"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> linklist = <span class="hljs-keyword">new</span> LinkList.LinkList();

    <span class="hljs-comment">// 入队列</span>
    <span class="hljs-keyword">this</span>.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{
        linklist.append(item);
    };

    <span class="hljs-comment">// 出队列</span>
    <span class="hljs-keyword">this</span>.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.remove_head();
    };

    <span class="hljs-comment">// 返回队首</span>
    <span class="hljs-keyword">this</span>.head = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.head();
    };

    <span class="hljs-comment">// 返回队尾</span>
    <span class="hljs-keyword">this</span>.tail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.tail();
    };

    <span class="hljs-comment">// size</span>
    <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.length();
    };

    <span class="hljs-comment">//clear</span>
    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        linklist.clear();
    };

    <span class="hljs-comment">// isEmpty</span>
    <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> linklist.isEmpty();
    };
};


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonacci</span>(<span class="hljs-params">n</span>)</span>{
    queue = <span class="hljs-keyword">new</span> Queue();
    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 先放入斐波那契序列的前两个数值</span>
    queue.enqueue(<span class="hljs-number">1</span>);
    queue.enqueue(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">while</span>(index &lt; n<span class="hljs-number">-2</span>){
        <span class="hljs-comment">// 出队列一个元素</span>
        <span class="hljs-keyword">var</span> del_item = queue.dequeue();
        <span class="hljs-comment">// 取队列头部元素</span>
        <span class="hljs-keyword">var</span> head_item = queue.head();
        <span class="hljs-keyword">var</span> next_item = del_item + head_item;
        <span class="hljs-comment">// 将计算结果放入队列</span>
        queue.enqueue(next_item);
        index += <span class="hljs-number">1</span>;
    }
    queue.dequeue();
    <span class="hljs-keyword">return</span> queue.head();
};

<span class="hljs-built_in">console</span>.log(fibonacci(<span class="hljs-number">8</span>));

</code></pre>
<h3><a class="anchor" aria-hidden="true" id="翻转链表"></a><a href="#翻转链表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>翻转链表</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">var</span> node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> node3 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">3</span>);
<span class="hljs-keyword">var</span> node4 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">4</span>);
<span class="hljs-keyword">var</span> node5 = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">5</span>);


node1.next = node2;
node2.next = node3;
node3.next = node4;
node4.next = node5;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">node</span>)</span>{
    <span class="hljs-keyword">var</span> curr_node = node;
    <span class="hljs-keyword">while</span>(curr_node){
        <span class="hljs-built_in">console</span>.log(curr_node.data);
        curr_node = curr_node.next;
    }
};
</code></pre>
<p><code>A =&gt; B =&gt; C =&gt; D</code></p>
<p><code>=&gt;</code></p>
<p><code>D =&gt; C =&gt; B =&gt; A</code></p>
<h4><a class="anchor" aria-hidden="true" id="迭代实现"></a><a href="#迭代实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>迭代实现</h4>
<blockquote>
<p>思路分析</p>
</blockquote>
<ul>
<li>首节点<code>A</code></li>
</ul>
<pre><code class="hljs css language-javascript">    A.next = 默认一个<span class="hljs-literal">null</span>

    结果： A
</code></pre>
<ul>
<li>节点<code>B</code></li>
</ul>
<pre><code class="hljs css language-javascript">    B.next = A(这个A怎么来， 上一轮迭代的<span class="hljs-literal">null</span>，改为A)
    结果： B =&gt; A
</code></pre>
<ul>
<li>节点<code>C</code></li>
</ul>
<pre><code class="hljs css language-javascript">    C.next = B(这个B怎么来， 上一轮迭代的A，改为B)
    结果：C =&gt; <span class="hljs-function"><span class="hljs-params">B</span> =&gt;</span> A
</code></pre>
<p>...</p>
<p>最终结果： <code>D =&gt; C =&gt; B =&gt; A</code></p>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript">
<span class="hljs-comment">// 迭代翻转</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse_iter</span>(<span class="hljs-params">head</span>)</span>{
    <span class="hljs-keyword">if</span>(!head){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-keyword">var</span> pre_node = <span class="hljs-literal">null</span>;     <span class="hljs-comment">// 前一个节点</span>
    <span class="hljs-keyword">var</span> curr_node = head;    <span class="hljs-comment">// 当前要翻转的节点</span>
    <span class="hljs-keyword">while</span>(curr_node){
        <span class="hljs-keyword">var</span> next_node = curr_node.next;    <span class="hljs-comment">// 下一个节点</span>
        curr_node.next = pre_node;         <span class="hljs-comment">// 对当前节点进行翻转</span>
        pre_node = curr_node;              <span class="hljs-comment">// pre_node向后滑动</span>
        curr_node = next_node;             <span class="hljs-comment">// curr_node向后滑动</span>
    }
    <span class="hljs-comment">//最后要返回pre_node,当循环结束时,pre_node指向翻转前链表的最后一个节点</span>
    <span class="hljs-keyword">return</span> pre_node;
};

print(reverse_digui(node1));
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="从尾到头打印链表"></a><a href="#从尾到头打印链表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从尾到头打印链表</h4>
<ul>
<li>不能翻转链表</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse_print</span>(<span class="hljs-params">head</span>)</span>{
    <span class="hljs-comment">// 递归终止条件</span>
    <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>
    } <span class="hljs-keyword">else</span> {
        reverse_print(head.next);  <span class="hljs-comment">// 全部打印完后</span>
        <span class="hljs-built_in">console</span>.log(head.data); <span class="hljs-comment">// 打印头节点</span>
    }
};
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="合并2个有序的链表"></a><a href="#合并2个有序的链表" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>合并2个有序的链表</h4>
<p>链表<code>A</code>：</p>
<p><code>1 =&gt; 4 =&gt; 6</code></p>
<p>链表<code>B</code>：</p>
<p><code>2 =&gt; 5 =&gt; 7 =&gt; 9</code></p>
<p>输出</p>
<p><code>1 =&gt; 2 =&gt; 4 =&gt; 5 =&gt; 6 =&gt; 8 =&gt; 9</code></p>
<blockquote>
<p>思路</p>
</blockquote>
<ul>
<li><p>链表<code>A</code>，链表<code>B</code>同步“循环”， 一一比较</p></li>
<li><p><code>1</code> &lt; <code>2</code>, 取<code>1</code>, 作为新链表<code>C</code>的头节点、尾节点</p></li>
<li><p><code>1</code>被取过了， 迭代到<code>1</code>.next， 即<code>4</code></p></li>
<li><p><code>4</code> &lt; <code>2</code>， 取<code>2</code>, 作为<code>c</code>链表尾节点.next节点</p></li>
<li><p>...</p></li>
<li><p><code>A</code>链表长度跟<code>B</code>链表的不一样，最后<code>A</code>的<code>6</code>被取走，留<code>B</code>的<code>7</code>、<code>9</code></p></li>
<li><p>找到<code>7</code>, 再来一次迭代，依次<code>push</code>到<code>C</code>链表的<code>tail</code></p></li>
<li><p>返回<code>C</code>链表</p></li>
</ul>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge_link</span>(<span class="hljs-params">head1, head2</span>)</span>{
    <span class="hljs-keyword">if</span>(head1 == <span class="hljs-literal">null</span>){
        <span class="hljs-keyword">return</span> head2;
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head2 == <span class="hljs-literal">null</span>){
        <span class="hljs-keyword">return</span> head1;
    }

    <span class="hljs-keyword">var</span> merge_head = <span class="hljs-literal">null</span>;   <span class="hljs-comment">// 合并后链表头</span>
    <span class="hljs-keyword">var</span> merge_tail = <span class="hljs-literal">null</span>;   <span class="hljs-comment">// 合并后链表尾</span>
    <span class="hljs-keyword">var</span> curr_1 = head1;
    <span class="hljs-keyword">var</span> curr_2 = head2;
    <span class="hljs-keyword">while</span>(curr_1 &amp;&amp; curr_2){
        <span class="hljs-comment">// 找到最小值</span>
        <span class="hljs-keyword">var</span> min_data;
        <span class="hljs-keyword">if</span>(curr_1.data &lt; curr_2.data) {
            min_data = curr_1.data;
            curr_1 = curr_1.next;
        }<span class="hljs-keyword">else</span>{
            min_data = curr_2.data;
            curr_2 = curr_2.next;
        }
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'min_data'</span>, min_data)

        <span class="hljs-keyword">if</span>(merge_head == <span class="hljs-literal">null</span>){
            merge_head = <span class="hljs-keyword">new</span> Node(min_data);
            merge_tail = merge_head;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">var</span> new_node = <span class="hljs-keyword">new</span> Node(min_data);
            <span class="hljs-comment">// 把new_node连接到合并链表</span>
            merge_tail.next = new_node;
            <span class="hljs-comment">// 尾节点指向新创建的节点</span>
            merge_tail = new_node;
        }

    }

    <span class="hljs-comment">// 链表可能还有一部分没有合并进来</span>
    <span class="hljs-keyword">var</span> rest_link = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span>(curr_1){
        rest_link = curr_1;
    }
    <span class="hljs-keyword">if</span>(curr_2){
        rest_link = curr_2;
    }

    <span class="hljs-keyword">while</span>(rest_link){
        <span class="hljs-keyword">var</span> new_node = <span class="hljs-keyword">new</span> Node(rest_link.data);
        merge_tail.next = new_node;
        merge_tail = new_node;
        rest_link = rest_link.next;
    }
    <span class="hljs-keyword">return</span> merge_head;
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="查找单链表中的倒数第idx个节点"></a><a href="#查找单链表中的倒数第idx个节点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找单链表中的倒数第idx个节点</h4>
<p><code>A =&gt; B =&gt; C =&gt; D =&gt; E</code></p>
<p><code>idx = 2</code></p>
<p>输出： <code>D</code></p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">var</span> node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'A'</span>);
<span class="hljs-keyword">var</span> node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'B'</span>);
<span class="hljs-keyword">var</span> node3 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'C'</span>);
<span class="hljs-keyword">var</span> node4 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'D'</span>);
<span class="hljs-keyword">var</span> node5 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'E'</span>);


node1.next = node2
node2.next = node3
node3.next = node4
node4.next = node5


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse_find</span>(<span class="hljs-params">head, idx</span>)</span>{
  <span class="hljs-keyword">let</span> cur_node = head
  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (cur_node) {
    len += <span class="hljs-number">1</span>
    cur_node = cur_node.next
  }
  <span class="hljs-keyword">if</span> (idx &gt;= len) {
    <span class="hljs-keyword">return</span> head
  }
  <span class="hljs-keyword">let</span> resetIdx = len - idx
  cur_node = head
  <span class="hljs-keyword">while</span> (resetIdx) {
    cur_node = cur_node.next
    resetIdx -= <span class="hljs-number">1</span>
  }
  <span class="hljs-keyword">return</span> cur_node
}

<span class="hljs-built_in">console</span>.log(
  reverse_find(node1, <span class="hljs-number">2</span>)
)
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="查找单链表中间节点"></a><a href="#查找单链表中间节点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>查找单链表中间节点</h4>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
    <span class="hljs-keyword">this</span>.data = data;
    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">var</span> node1 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'A'</span>);
<span class="hljs-keyword">var</span> node2 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'B'</span>);
<span class="hljs-keyword">var</span> node3 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'C'</span>);
<span class="hljs-keyword">var</span> node4 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'D'</span>);
<span class="hljs-keyword">var</span> node5 = <span class="hljs-keyword">new</span> Node(<span class="hljs-string">'E'</span>);


node1.next = node2
node2.next = node3
node3.next = node4
node4.next = node5


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find_middle</span>(<span class="hljs-params">head</span>)</span>{
  <span class="hljs-keyword">let</span> cur_node = head
  <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (cur_node) {
    len += <span class="hljs-number">1</span>
    cur_node = cur_node.next
  }
  <span class="hljs-keyword">let</span> midIdx = <span class="hljs-built_in">Math</span>.ceil(len / <span class="hljs-number">2</span>)
  cur_node = head
  <span class="hljs-keyword">while</span> (--midIdx) {
    cur_node = cur_node.next
  }
  <span class="hljs-keyword">return</span> cur_node
}

<span class="hljs-built_in">console</span>.log(
  find_middle(node1)
)
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/09/05/stack">实现栈并应用</a></h1><p class="post-meta">September 5, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="栈的特性"></a><a href="#栈的特性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>栈的特性</h3>
<ul>
<li>只能从栈顶操作</li>
<li>先进的后出</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="数组实现"></a><a href="#数组实现" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>数组实现</h3>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// 使用数组存储数据</span>
    <span class="hljs-keyword">var</span> items = [];  

    <span class="hljs-comment">// push方法向栈里压入一个元素</span>
    <span class="hljs-keyword">this</span>.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{
        items.push(item);
    };

    <span class="hljs-comment">// pop方法把栈顶的元素弹出</span>
    <span class="hljs-keyword">this</span>.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> items.pop();
    };

    <span class="hljs-comment">// top 方法返回栈顶元素</span>
    <span class="hljs-keyword">this</span>.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> items[items.length - <span class="hljs-number">1</span>];
    };

    <span class="hljs-comment">// isEmpty返回栈是否为空</span>
    <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> items.length == <span class="hljs-number">0</span>;
    };

    <span class="hljs-comment">// size方法返回栈的大小</span>
    <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> items.length;
    };

    <span class="hljs-comment">// clear 清空栈</span>
    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        items = []
    };
}
exports.Stack = Stack;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="应用"></a><a href="#应用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用</h3>
<h4><a class="anchor" aria-hidden="true" id="利用栈的进栈出栈存储数据-做业务判断"></a><a href="#利用栈的进栈出栈存储数据-做业务判断" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用栈的进栈出栈存储数据，做业务判断</h4>
<p>合法括号</p>
<p><code>dfdsf(r23)</code> 合法</p>
<p><code>dfdsf(r23))</code> 不合法</p>
<blockquote>
<p>思路</p>
</blockquote>
<ul>
<li>遍历</li>
<li>若是<code>(</code>，进栈； <code>['(']</code></li>
<li>若是<code>)</code>, 若栈中有<code>(</code>, 出栈抵消掉，栈又变成空栈<code>[]</code>； 若栈中无<code>(</code>，抵消不了；</li>
<li>遍历完成，最理想的情况，全部成双抵消，栈为空</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="利用栈弹出的都是最新压入栈的数据-即后进先出特点"></a><a href="#利用栈弹出的都是最新压入栈的数据-即后进先出特点" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用栈弹出的都是最新压入栈的数据，即后进先出特点</h4>
<p>逆波兰表达式</p>
<p><code>[&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</code></p>
<p>相当于</p>
<p><code>(10 * (6 / (((9 + 3) * -11))) + 17) + 5</code></p>
<blockquote>
<p>思路</p>
</blockquote>
<ul>
<li><p>实例出来一个栈</p></li>
<li><p>遍历数组</p>
<pre><code class="hljs">入栈:
[<span class="hljs-number">10</span>]
[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>]
[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>]
[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>]
</code></pre></li>
<li><p>遇到<code>+</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">3</span>
弹出<span class="hljs-number">9</span>
栈：[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>]
<span class="hljs-number">9</span> + <span class="hljs-number">3</span> = <span class="hljs-number">12</span>
入栈
栈：[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>]
</code></pre></li>
<li><p>继续</p>
<pre><code class="hljs">[<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">12</span>， <span class="hljs-number">-11</span>]
</code></pre></li>
</ul>
<ul>
<li><p>遇到<code>*</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">-11</span>
弹出<span class="hljs-number">12</span>
栈： [<span class="hljs-number">10</span>, <span class="hljs-number">6</span>]
计算<span class="hljs-number">12</span> * <span class="hljs-number">-11</span> = <span class="hljs-number">-132</span>
入栈
栈：[<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-132</span>]
</code></pre></li>
<li><p>遇到<code>/</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">-132</span>
弹出<span class="hljs-number">6</span>
栈：[<span class="hljs-number">10</span>]
<span class="hljs-number">6</span> / <span class="hljs-number">-132</span> = <span class="hljs-number">-0.45</span>
进栈
栈：[<span class="hljs-number">10</span>， <span class="hljs-number">-0.45</span>]
</code></pre></li>
<li><p>遇到<code>*</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">-0.45</span>
弹出<span class="hljs-number">10</span>
栈：[]
<span class="hljs-number">10</span> * <span class="hljs-number">-0.45</span> = <span class="hljs-number">-4.5</span>
进栈
栈：[<span class="hljs-number">-4.5</span>]
</code></pre></li>
</ul>
<ul>
<li>继续
<pre><code class="hljs">栈：[<span class="hljs-number">-4.5</span>, <span class="hljs-number">17</span>]
</code></pre></li>
</ul>
<ul>
<li><p>遇到<code>+</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">17</span>
弹出<span class="hljs-number">-4.5</span>
栈：[]
<span class="hljs-number">-4.5</span> + <span class="hljs-number">17</span> = <span class="hljs-number">12.5</span>
进栈
栈：[<span class="hljs-number">12.5</span>]
</code></pre></li>
<li><p>继续</p>
<pre><code class="hljs">栈：[<span class="hljs-number">12.5</span>, <span class="hljs-number">5</span>]
</code></pre></li>
<li><p>遇到<code>+</code></p>
<pre><code class="hljs">弹出<span class="hljs-number">5</span>
弹出<span class="hljs-number">12.5</span>
栈：[]
<span class="hljs-number">12.5</span> + <span class="hljs-number">5</span> = <span class="hljs-number">17.5</span>
进栈
栈：[<span class="hljs-number">17.5</span>]
</code></pre></li>
<li><p>出栈<code>17.5</code></p></li>
</ul>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calc_exp</span>(<span class="hljs-params">exp</span>)</span>{
    <span class="hljs-keyword">var</span> stack = <span class="hljs-keyword">new</span> Stack();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; exp.length;i++){
        <span class="hljs-keyword">var</span> item = exp[i];

        <span class="hljs-keyword">if</span>([<span class="hljs-string">"+"</span>, <span class="hljs-string">"-"</span>, <span class="hljs-string">"*"</span>, <span class="hljs-string">"/"</span>].indexOf(item) &gt;= <span class="hljs-number">0</span>){
            <span class="hljs-comment">// 从栈顶弹出两个元素</span>
            <span class="hljs-keyword">var</span> value_1 = stack.pop();
            <span class="hljs-keyword">var</span> value_2 = stack.pop();
            <span class="hljs-comment">// 拼成表达式</span>
            <span class="hljs-keyword">var</span> exp_str = value_2 + item + value_1;
            <span class="hljs-comment">// 计算并取整</span>
            <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">eval</span>(exp_str));
            <span class="hljs-comment">// 将计算结果压如栈</span>
            stack.push(res.toString());
        }<span class="hljs-keyword">else</span>{
            stack.push(item);
        }
    }
    <span class="hljs-comment">// 表达式如果是正确的,最终,栈里还有一个元素,且正是表达式的计算结果</span>
    <span class="hljs-keyword">return</span> stack.pop();
};
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="利用栈顶弹出实现最小值"></a><a href="#利用栈顶弹出实现最小值" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>利用栈顶弹出实现最小值</h4>
<p>有一种需求，比较最大值或最小值，通过栈的方式来实现比较</p>
<blockquote>
<p>思路</p>
</blockquote>
<ul>
<li><p>实例一个专门存最大或最小的栈A</p></li>
<li><p>遍历一个已知数组</p></li>
<li><p>只要保证栈A的栈顶一直是最小的值即可(每一个都跟栈顶比较)</p></li>
<li><p>遍历完成，弹出栈A栈顶值</p></li>
</ul>
<blockquote>
<p>演示</p>
</blockquote>
<p><code>[5, 2, 4, 8, 1, 4, 7]</code></p>
<ul>
<li><p><code>5:</code> <code>A[5]</code></p></li>
<li><p><code>2:</code> <code>A[5, 2]</code></p></li>
<li><p><code>4:</code> <code>A[5, 2]</code></p></li>
<li><p><code>8:</code> <code>A[5, 2]</code></p></li>
<li><p><code>1:</code> <code>A[5, 2, 1]</code></p></li>
<li><p><code>4:</code> <code>A[5, 2, 1]</code></p></li>
<li><p><code>7:</code> <code>A[5, 2, 1]</code></p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="使用2个栈实现一个队列"></a><a href="#使用2个栈实现一个队列" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用2个栈实现一个队列</h4>
<blockquote>
<p>思路</p>
</blockquote>
<pre><code class="hljs">栈A[]
栈B[]

入列<span class="hljs-number">1</span>
栈A[<span class="hljs-number">1</span>]
栈B[]

入列<span class="hljs-number">2</span>
栈A[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
栈B[]

入列<span class="hljs-number">3</span>
栈A[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
栈B[]

出列
拿到<span class="hljs-number">1</span>值
栈只能栈顶弹出

栈A[<span class="hljs-number">1</span>]
栈B[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>]
出栈<span class="hljs-number">1</span>即拿到
现在：
栈A[]
栈B[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>]
再倒入
栈A[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
栈B[]

入列<span class="hljs-number">4</span>
栈A[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
栈B[]

访问队列队首
栈A[<span class="hljs-number">2</span>]
栈B[<span class="hljs-number">4</span>，<span class="hljs-number">3</span>]
访问栈A的栈顶top()，返回
恢复
栈A[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
栈B[]
</code></pre>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SQueue</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">this</span>.s1 = <span class="hljs-keyword">new</span> Stack()
  <span class="hljs-keyword">this</span>.s2 = <span class="hljs-keyword">new</span> Stack()
  
  <span class="hljs-comment">// 入列</span>
  <span class="hljs-keyword">this</span>.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
    <span class="hljs-keyword">this</span>.s1.push(item)
  }
  
  <span class="hljs-comment">// 出列</span>
  <span class="hljs-keyword">this</span>.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.s1.size() &gt; <span class="hljs-number">1</span>) {
       <span class="hljs-keyword">this</span>.s2.push(<span class="hljs-keyword">this</span>.s1.pop())
    }
    <span class="hljs-keyword">const</span> deItem = <span class="hljs-keyword">this</span>.s1.pop()
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.s2.size()) {
       <span class="hljs-keyword">this</span>.s1.push(<span class="hljs-keyword">this</span>.s2.pop())  
    }
    <span class="hljs-keyword">return</span> deItem
  }
  
  <span class="hljs-comment">// 访问队首</span>
  <span class="hljs-keyword">this</span>.head = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.s1.size() &gt; <span class="hljs-number">1</span>) {
       <span class="hljs-keyword">this</span>.s2.push(<span class="hljs-keyword">this</span>.s1.pop())
    }
    <span class="hljs-keyword">const</span> headtem = <span class="hljs-keyword">this</span>.s1.top()
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.s2.size()) {
       <span class="hljs-keyword">this</span>.s1.push(<span class="hljs-keyword">this</span>.s2.pop())  
    }
    <span class="hljs-keyword">return</span> headtem
  }
}
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/liuxiaobai/blog/2019/09/05/queue">实现队列并应用</a></h1><p class="post-meta">September 5, 2019</p><div class="authorBlock"><p class="post-authorName"><a href="" target="_blank" rel="noreferrer noopener">六小白</a></p></div></header><article class="post-content"><div><span><h3><a class="anchor" aria-hidden="true" id="队列"></a><a href="#队列" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>队列</h3>
<ul>
<li>先进后出</li>
</ul>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.stores = []
}

Queue.prototype.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
  <span class="hljs-keyword">this</span>.stores.push(item)
}

Queue.prototype.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stores.shift()
}

Queue.prototype.head = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stores[<span class="hljs-number">0</span>]
}

Queue.prototype.size = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stores.length
}

Queue.prototype.tail = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.stores[<span class="hljs-keyword">this</span>.stores.length - <span class="hljs-number">1</span>]
}

Queue.prototype.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>.stores.length
}

Queue.prototype.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.stores = []
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="应用"></a><a href="#应用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用</h3>
<ul>
<li>利用队列队首出，队尾进特性</li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="约瑟夫环"></a><a href="#约瑟夫环" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>约瑟夫环</h4>
<p>一个数组[0-100], 每隔两个数删一个数，到末尾，再从头开始，直到最后一个，求其值</p>
<blockquote>
<p>思路</p>
</blockquote>
<pre><code class="hljs">队列： 出[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]进

出<span class="hljs-number">0</span>， <span class="hljs-number">0</span>不满足条件，继续后面排队
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>]   <span class="hljs-number">1</span>

出<span class="hljs-number">1</span>， <span class="hljs-number">1</span>不满足条件，继续后面排队
[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]   <span class="hljs-number">2</span>

出<span class="hljs-number">2</span>， <span class="hljs-number">2</span>满足条件，干掉
[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]   <span class="hljs-number">3</span>


出<span class="hljs-number">3</span>，<span class="hljs-number">3</span>不满足条件，继续后面排队
[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]   <span class="hljs-number">4</span>

出<span class="hljs-number">4</span>，<span class="hljs-number">4</span>不满足条件，继续后面排队
[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]  <span class="hljs-number">5</span>


出<span class="hljs-number">5</span>，<span class="hljs-number">5</span>满足条件，干掉
[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]   <span class="hljs-number">6</span>

出<span class="hljs-number">6</span>，<span class="hljs-number">6</span>不满足条件，继续后面排队
[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>, <span class="hljs-number">6</span>]  <span class="hljs-number">7</span>

出<span class="hljs-number">7</span>，<span class="hljs-number">7</span>不满足条件，继续后面排队
[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]  <span class="hljs-number">8</span>

出<span class="hljs-number">8</span>，<span class="hljs-number">8</span>满足条件，干掉
[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]  <span class="hljs-number">9</span>

...

最后队列中size为<span class="hljs-number">1</span>时， 停止循环，访问队列的head即可
</code></pre>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleRing</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> Queue()
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
    queue.enqueue(arr[i])
  }
  <span class="hljs-keyword">let</span> stepIdx = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (queue.size() != <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">let</span> item = queue.dequeue()
    stepIdx += <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> (stepIdx % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) {
      queue.enqueue(item)
    }
  }
  <span class="hljs-keyword">return</span> queue.head()
}
</code></pre>
<blockquote>
<p>执行过程</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/stupidWall/liuxiaobai/master/img/blog/2019/1567655806583.png" /></p>
<h4><a class="anchor" aria-hidden="true" id="斐波切那数列"></a><a href="#斐波切那数列" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>斐波切那数列</h4>
<p><code>[1,1,2,3,5]</code></p>
<p>输入n，返回对应值</p>
<blockquote>
<p>思路</p>
</blockquote>
<pre><code class="hljs">队列 [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]

当n = <span class="hljs-number">1</span> 或 <span class="hljs-number">2</span>
出列： [<span class="hljs-number">1</span>]
返回队首: <span class="hljs-number">1</span>


当n = <span class="hljs-number">3</span>
出列<span class="hljs-number">1</span>
队首<span class="hljs-number">1</span>
<span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>
入列<span class="hljs-number">2</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
最后出列<span class="hljs-number">1</span>， 返回队首<span class="hljs-number">2</span>

当n = <span class="hljs-number">5</span>

队列演变:
[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
[<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]

最后出列<span class="hljs-number">3</span>， 返回队首<span class="hljs-number">5</span>
</code></pre>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fibonaci</span>(<span class="hljs-params">num</span>) </span>{
  <span class="hljs-keyword">const</span> myQ = <span class="hljs-keyword">new</span> Queue()
  myQ.enqueue(<span class="hljs-number">1</span>)
  myQ.enqueue(<span class="hljs-number">1</span>)
  <span class="hljs-keyword">let</span> stepIdx = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (stepIdx &lt; num - <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">let</span> deO = myQ.dequeue()
    <span class="hljs-keyword">let</span> headO = myQ.head()
    myQ.enqueue(deO + headO)
    stepIdx += <span class="hljs-number">1</span>
  }
  myQ.dequeue()
  <span class="hljs-keyword">return</span> myQ.head()
}
</code></pre>
<pre><code class="hljs css language-javascript">fibonaci(<span class="hljs-number">8</span>)
<span class="hljs-comment">// 21</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="使用队列实现栈"></a><a href="#使用队列实现栈" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用队列实现栈</h4>
<ul>
<li><p>入栈</p></li>
<li><p>出栈</p></li>
<li><p>访问栈顶</p></li>
</ul>
<p>实现上面的三个方法</p>
<blockquote>
<p>思路</p>
</blockquote>
<ul>
<li><p>创建2个队列： A队列、B队列</p></li>
<li><p>入栈<code>1</code>、<code>2</code>、<code>3</code></p>
<pre><code class="hljs">入栈 <span class="hljs-number">1</span>
队列A [<span class="hljs-number">1</span>]
队列B []


入栈 <span class="hljs-number">2</span>
队列A [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
队列B []


入栈 <span class="hljs-number">3</span>
队列A [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
队列B []
</code></pre></li>
<li><p>出栈</p>
<pre><code class="hljs">想办法从队列A中取<span class="hljs-number">3</span>

倒入队列B
队列A [<span class="hljs-number">3</span>]
队列B [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]

队列A剩下最后一个，使用出列获取<span class="hljs-number">3</span>
最后是出栈成功
队列A []
队列B [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
</code></pre></li>
<li><p>再入栈4</p>
<pre><code class="hljs">队列A []
队列B [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]
</code></pre></li>
<li><p>访问栈顶值</p>
<pre><code class="hljs">队列A [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]
队列B []
调队列A的tail方法
</code></pre>
<blockquote>
<p>代码</p>
</blockquote></li>
</ul>
<pre><code class="hljs css language-javascript">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">QStack</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.q1 = <span class="hljs-keyword">new</span> Queue()
    <span class="hljs-keyword">this</span>.q2 = <span class="hljs-keyword">new</span> Queue()
    <span class="hljs-keyword">this</span>.findQ = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.q2.isEmpty() &amp;&amp; <span class="hljs-keyword">this</span>.q1.isEmpty()) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.q2
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.q1
    }
  }

  <span class="hljs-comment">// 入栈</span>
  QStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'sssss'</span>, <span class="hljs-keyword">this</span>.findQ())
    <span class="hljs-keyword">this</span>.findQ().enqueue(item)
  }

  <span class="hljs-comment">// 出栈</span>
  QStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.findQ().size() &gt; <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">this</span>.q2.enqueue(
        <span class="hljs-keyword">this</span>.findQ().dequeue()
      )     
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.findQ().dequeue()
  }

  <span class="hljs-comment">// 栈顶</span>
  QStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.findQ().tail()
  }


  <span class="hljs-keyword">const</span> qs = <span class="hljs-keyword">new</span> QStack()

  qs.push(<span class="hljs-string">'A'</span>)
  qs.push(<span class="hljs-string">'B'</span>)
  qs.push(<span class="hljs-string">'C1'</span>)

  <span class="hljs-built_in">console</span>.log(
    <span class="hljs-string">'xxxxx'</span>,
    qs.pop()
  )
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next" href="/liuxiaobai/blog/page2/">Next →</a></div></div></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'my-api-key',
                indexName: 'my-index-name',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>